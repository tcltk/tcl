# This file contains a collection of tests for the procedures in the
# file tclParse.c.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright © 1997 Sun Microsystems, Inc.
# Copyright © 1998-1999 Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

set mytest 0

if {!$::mytest} { ;# change to incorporate with official testing
    # Official test suite mode
    if {"::tcltest" ni [namespace children]} {
        package require tcltest 2.5
        namespace import -force ::tcltest::*
    }
    
    ::tcltest::loadTestedCommands
    catch [list package require -exact tcl::test [info patchlevel]]
    
    
} else {

set testCount 0
set passCount 0
set failCount 0
namespace eval ::tcl::test::subexpr {
proc test {name description body expected} {
	global testCount passCount failCount
	incr testCount
	puts "\n=========================================="
	puts "Test $testCount: $name"
	puts "=========================================="
	puts "Description: $description"
	puts ""
	puts "Code:"
	foreach line [split $body "\n"] {
		set line [string trim $line]
		if {$line ne ""} {
			puts "  $line"
		}
	}
	puts ""
	set result ""
	set status "PASS"
	uplevel 1 {unset -nocomplain msg}
	if {[catch {uplevel 1 $body} result]} {
		set status "FAIL"
		puts "Result: ERROR - $result"
		puts "Expected: $expected"
	} else {



		if {$result eq $expected} {
		    puts "Result: $result"
		    if {[uplevel 1 {info exists msg}]} {
		        puts "Captured: [string range [string map {\n <nl>} [uplevel 1 {set msg}]] 0 79]"
		    }
		    puts "Expected: $expected"

		} else {
			set status "FAIL"
			puts "Result: $result"
			puts "Expected: $expected"
		}
	}
	puts ""
	puts "Status: $status"
	if {$status eq "PASS"} {
		incr passCount
	} else {
		incr failCount
	}
}

} ;# end namespace subexpr
} ;# end of local testing on $mytest


namespace eval ::tcl::test::subexpr {

# ==========================================
# Test Cases
# ==========================================

#!/usr/bin/env tclsh

# [Keep your test runner proc exactly as-is from before]

if { $::mytest } {
puts "======================================================"
puts "Test Suite for TIP 672: \$((expr)) Syntax"
puts "======================================================"
}

# ==========================================
# Basic Tests
# ==========================================


test basic-1.1 {Basic addition with two variables} {
    set a 5
    set b 10
    set result $(($a + $b))
} 15

test basic-1.2 {Subtraction of two variables} {
    set x 20
    set y 7
    set result $(($x - $y))
} 13

test basic-1.3 {Multiplication of two variables} {
    set m 6
    set n 7
    set result $(($m * $n))
} 42

test basic-1.4 {Division of two variables} {
    set p 100
    set q 4
    set result $(($p / $q))
} 25

test basic-1.5 {Modulo operation} {
    set x 17
    set y 5
    set result $(($x % $y))
} 2

test string-2.1 {Expression embedded in quoted string} {
    set x 3
    set y 7
    set msg "The sum is $(($x + $y))"
} "The sum is 10"

test compare-2.2 {Less than comparison} {
    set a 5
    set b 10
    set result $(($a < $b))
} 1

test compare-2.3 {Equality comparison} {
    set m 7
    set n 7
    set result $(($m == $n))
} 1

test nested-3.1 {Nested parentheses in expression} {
    set a 2
    set b 3
    set c 4
    set result $((($a + $b) * ($c - 1))
} 15

test edge-3.2 {Negative numbers} {
    set x -5
    set y 10
    set result $(($x + $y))
} 5








test edge-3.3 {Floating point arithmetic} {
    set a 3.5
    set b 2.0
    set result $(($a * $b))
} 7.0

test edge-3.4 {Expression with zero} {
    set x 0
    set y 42
    set result $(($x + $y))
} 42

test edge-3.5 {Single variable in expression} {
    set value 99
    set result $(($value))
} 99

test edge-3.6 {Expression with many spaces} {
    set a 10
    set b 20
    set result $((   $a   +   $b   ))
} 30

test edge-3.7 {Very long expression} {
    set a 1
    set b 2
    set c 3
    set d 4
    set e 5
    set result $(($a + $b + $c + $d + $e))
} 15







test error-4.1 {Undefined variable in expression} -body {
    catch {$(($undefined_var + 5))} msg
    string match "*no such variable*" $msg
} -result 1

test error-4.2 {Missing closing parenthesis} -constraints knownBug -body {
    catch {set x $(($a + $b)} msg
    string match "*missing close-paren*" $msg
}  -result 1

test error-4.3 {Division by zero} -body {
    set a 10
    set b 0
    catch {$(($a / $b))} msg
    string match "*divide by zero*" $msg
}  -result 1

test error-4.4 {Invalid syntax in expression} -body {
    set a 5
    catch {$(($a +)} msg
    string match "*missing operand*" $msg
} -result 1

test error-4.5 {Mismatched nested parentheses} -constraints knownBug -body {
    set a 2
    set b 3
    catch {$((($a + $b))} msg
    string match "*missing close-paren*" $msg
} -result 1


# ==========================================
# Paren-matching: Quoted strings
# ==========================================

test subexpr-4.6 {Paren inside quoted string} {
    set x "("
    set result $(($x eq "("))
} 1

test subexpr-4.7 {Closing paren inside quoted string} {
    set x ")"
    set result $(($x eq ")"))
} 1

test subexpr-4.8 {Both parens inside quoted string} {
    set x "()"
    set result $(($x eq "()"))
} 1

test subexpr-4.9 {Expression with quoted paren on left} {
    set result $(("(" eq "("))
} 1

test subexpr-4.10 {Expression with quoted paren on right} {
    set result $(("x" eq ")"))
} 0

# ==========================================
# Paren-matching: Escaped quotes
# ==========================================

test subexpr-4.11 {Escaped quote before paren} {
    set result $(("\"(" eq "\"("))
} 1

test subexpr-4.12 {Escaped quote after paren} {
    set result $(("(\"" eq "(\""))
} 1

test subexpr-4.13 {Multiple escaped quotes} {
    set result $(("\"\"(" eq "\"\"("))
} 1

test subexpr-4.14 {Escaped backslash before paren} {
    set result $(("\\(" eq "\\("))
} 1

test subexpr-4.15 {Escaped backslash and quote} {
    set result $(("\\\"(" eq "\\\"("))
} 1





# ==========================================
# Paren-matching: Quoted strings
# ==========================================

test subexpr-4.6 {Paren inside quoted string} {
    set x "("
    set result $(($x eq "("))
} 1

test subexpr-4.7 {Closing paren inside quoted string} {
    set x ")"
    set result $(($x eq ")"))
} 1

test subexpr-4.8 {Both parens inside quoted string} {
    set x "()"
    set result $(($x eq "()"))
} 1

test subexpr-4.9 {Expression with quoted paren on left} {
    set result $(("(" eq "("))
} 1

test subexpr-4.10 {Expression with quoted paren on right} {
    set result $(("x" eq ")"))
} 0

# ==========================================
# Paren-matching: Escaped quotes
# ==========================================

test subexpr-4.11 {Escaped quote before paren} {
    set result $(("\"(" eq "\"("))
} 1

test subexpr-4.12 {Escaped quote after paren} {
    set result $(("(\"" eq "(\""))
} 1

test subexpr-4.13 {Multiple escaped quotes} {
    set result $(("\"\"(" eq "\"\"("))
} 1

test subexpr-4.14 {Escaped backslash before paren} {
    set result $(("\\(" eq "\\("))
} 1

test subexpr-4.15 {Escaped backslash and quote} {
    set result $(("\\\"(" eq "\\\"("))
} 1

# ==========================================
# Paren-matching: Command substitutions
# ==========================================

test subexpr-4.16 {Command sub returning paren} {
    set result $(([string index "(" 0] eq "("))
} 1

test subexpr-4.17 {Command sub with parens in it} {
    set result $(([string length "(test)"] + 1))
} 7

test subexpr-4.18 {Nested command sub with string match} {
    set result $(([string match "(*)" "(x)"] == 1))
} 1

test subexpr-4.19 {Command sub using expr with parens} {
    set result $(([expr {1 + 1}] + (2 * 3)))
} 8

test subexpr-4.20 {Multiple command subs with parens} {
    set result $(([string index "(" 0] eq [string index ")" 0]))
} 0




# ==========================================
# Deeply nested parens (20-30 levels)
# ==========================================

test subexpr-4.21 {Deeply nested parens - 20 levels} {
    set result $(((((((((((((((((((((1 + 1)))))))))))))))))))))
} 2

test subexpr-4.22 {Deeply nested parens - 25 levels with arithmetic} {
    set result $((((((((((((((((((((((((((2 * 3))))))))))))))))))))))))))
} 6

test subexpr-4.23 {Deeply nested parens - 30 levels} {
    set result $(((((((((((((((((((((((((((((((5 + 10)))))))))))))))))))))))))))))))
} 15

test subexpr-4.24 {Deeply nested with variables - 20 levels} {
    set a 7
    set b 3
    set result $((((((((((((((((((((($a - $b)))))))))))))))))))))
} 4

test subexpr-4.25 {Deeply nested complex expression - 25 levels} {
    set x 2
    set result $(((((((((((((((((((((((((($x * $x * $x))))))))))))))))))))))))))
} 8

# ==========================================
# Mixed: quotes, escapes, and command subs
# ==========================================

test subexpr-4.26 {Command sub with quoted paren comparison} {
    set x "("
    set result $(([string match "(" $x] && ")" eq ")"))
} 1

test subexpr-4.27 {Quoted paren with command sub result} {
    set result $(("(" eq [string index "test" 0]))
} 0

test subexpr-4.28 {Command sub returning paren in comparison} {
    set result $(([string index "()" 0] eq "("))
} 1

test subexpr-4.29 {Multiple command subs with quoted parens} {
    set result $(([string length "("] + [string length ")"] == 2))
} 1

test subexpr-4.30 {Escaped quote with command sub and parens} {
    set result $(("\"(" eq [string range "\"(test" 0 1]))
} 1



# ==========================================
# Whitespace and formatting edge cases
# ==========================================

test subexpr-4.31 {Extra spaces around nested parens} {
    set result $((  (  1  +  2  )  ))
} 3

test subexpr-4.32 {Command sub with tabs in quoted string} {
    set result $(([string length "\t\t\t"] == 3))
} 1

test subexpr-4.33 {Newlines in expression} {
    set result $((
        1 + 2
    ))
} 3

test subexpr-4.34 {Multiple newlines with nested parens} {
    set a 5
    set b 10
    set result $(((
        (
            $a + $b
        )
    )))
} 15

test subexpr-4.35 {Whitespace before closing paren} {
    set result $((1 + 2   ))
} 3

test subexpr-4.36 {No whitespace at all} {
    set result $(((1+2)*(3+4)))
} 21

test subexpr-4.37 {Mixed whitespace with quotes} {
    set result $((  "("  eq  "("  ))
} 1

test subexpr-4.38 {Whitespace in command sub with parens} {
    set result $(( [string length "( )"] + 1 ))
} 4

test subexpr-4.39 {Extreme whitespace} {
    set result $((   (   (   1   )   )   ))
} 1

test subexpr-4.40 {Newlines with command subs} {
    set result $(([string index "()" 0] 
        eq 
        "("))
} 1



# ==========================================
# Braces inside expressions
# ==========================================

test subexpr-4.41 {Braces around literal number} {
    set result $((1 + {2}))
} 3

test subexpr-4.42 {Multiple braced literals} {
    set result $(({1} + {2}))
} 3

test subexpr-4.43 {Braced literal with parens} {
    set result $((({1} + {2}) * 3))
} 9

# ==========================================
# Special characters in quoted strings
# ==========================================

test subexpr-4.44 {Dollar sign in quoted string} {
    set result $(("$" eq "$"))
} 1

test subexpr-4.45 {Backslash in quoted string} {
    set result $(("\\" eq "\\"))
} 1

test subexpr-4.46 {Mixed parens in quotes} {
    set result $(("()" eq "()"))
} 1

test subexpr-4.47 {Semicolon in quoted string} {
    set result $((";" eq ";"))
} 1











# ==========================================
# Error conditions - missing close paren
# ==========================================

test subexpr-error-4.48 {Missing close paren} -constraints knownBug -body {
    catch {set result $((1 + 2)} msg
    string match "*missing close-paren*" $msg
    set msg
} -result 1

test subexpr-error-4.49 {Missing close paren with quotes} -constraints knownBug -body {
    catch {set result $(("test" eq "test")} msg
    string match "*missing close-paren*" $msg
} -result 1

test subexpr-error-4.50 {Missing close paren with nested parens} -body {
    catch {set result $(((1 + 2)} msg
    string match "*missing close-paren*" $msg
} -result 1

test subexpr-error-4.51 {Missing close paren with command sub} -constraints knownBug -body {
    catch {set result $(([string length "test"])} msg
    string match "*missing close-paren*" $msg
} -result 1

# ==========================================
# Error conditions - unbalanced quotes
# ==========================================

test subexpr-error-4.52 {Unbalanced quote in expression} -body {
    catch {set result $("test eq "test")} msg
    expr {$msg ne ""}
} -result 1

test subexpr-error-4.53 {Unclosed quote at end} -body {
    catch {set result $(1 + "test)} msg
    expr {$msg ne ""}
} -result 1

# ==========================================
# Error conditions - invalid expressions
# ==========================================

test subexpr-error-4.54 {Empty expression} -body {
    catch {set result $(())} msg
    string match "*empty expression*" $msg
} -result 1

test subexpr-error-4.55 {Just whitespace} -body {
    catch {set result $((   ))} msg
    string match "*empty expression*" $msg
} -result 1

test subexpr-error-4.56 {Double plus interpreted as unary} -body {
    catch {set result $((1 ++ 2))} msg
    expr {$msg eq "3"}
} -result 1

test subexpr-error-4.57 {Unbalanced nested parens - too many open} -constraints knownBug -body {
    catch {set result $((((1 + 2)))} msg
    string match "*missing close-paren*" $msg
} -result 1

test subexpr-edge-4.58 {bare string with unescaped $. and no (} { ;# these two below assume mode 2 with =, but should work in any case
    catch {set result $=} msg
    expr {$msg eq "\$\="}
} 1


test subexpr-edge-4.59 {bare string with unescaped $. and no ( inside quotes} {
    catch {set result "$="} msg
    expr {$msg eq "\$\="}
} 1


} ;# end namespace

# ==========================================
# Summary
# ==========================================

if { $::mytest } {
	puts "\n======================================================"
	puts "Test Summary"
	puts "======================================================"
	puts "Total tests: $testCount"
	puts "Passed: $passCount"
	puts "Failed: $failCount"
	puts "======================================================"
	
	if {$failCount > 0} {
		exit 1
	}
} else {
	
		cleanupTests
	
	
} ;# end mytest
catch {namespace delete ::tcl::test::subexpr}
return


