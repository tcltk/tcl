# Commands covered:  array
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 2016 Andy Goth
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.

if {[lsearch [namespace children] ::tcltest] < 0} {
    package require tcltest 2
}
::tcltest::loadTestedCommands
catch {package require -exact Tcltest [info patchlevel]}
set namespaces [namespace children]
set procs [info procs]
set vars [info vars]

# [array] subcommand  arrayName             mode and filter
# ------------------  --------------------  ---------------
# anymore             array required        not allowed
# donesearch          array required        not allowed
# exists              anything              optional
# get                 anything              optional
# names               anything              optional
# nextelement         array required        not allowed
# set                 array or nonexistent  not allowed
# size                anything              optional
# startsearch         array required        optional
# statistics          array required        not allowed
# unset               anything              optional
# (unique abbrev)     (see above)           (see above)
# (ambiguous abbrev)  (error)               (error)
# (invalid)           (error)               (error)

# Possible arrayName arguments:
# - empty array
# - non-empty array
# - nonexistent
# - proc slot only
# - scalar variable
# - element of empty array
# - element of nonexistent array
# - element of proc-slot-only array
# - element of scalar variable
# - existing element of array
# - nonexistent element of array
# - bad namespace
# - array with array trace that causes error
# - array with array trace that does not cause error
# - (omitted)

# Possible mode and pattern arguments:
# - (no filter)
# - (default)
# - -exact
# - -glob
# - -regexp
# - -regexp (with invalid regexp pattern)

# oxfordJoin --
# and --
# or --
# Joins a list by commas, a conjunction, or both, using Oxford comma rules,
# matching Tcl's internal algorithm for displaying lists in error messages.
proc oxfordJoin {conjunction list} {
    if {[llength $list] > 1} {
        lset list end "$conjunction [lindex $list end]"
    }
    if {[llength $list] < 3} {
        join $list " "
    } else {
        join $list ", "
    }
}
interp alias {} and {} oxfordJoin and
interp alias {} or {} oxfordJoin or

# samples --
# Produces a list of sample arguments, given a list of parameters.
# Customizations can be applied via $args.
proc samples {params args} {
    set map [dict merge {
        arrayName   a
        searchId    s-1-a
        ?mode?      -exact
        ?pattern?   hello
        list        {hello world}
    } $args]
    lmap param $params {dict get $map $param}
}

# test --
# Wrapper around [::tcltest::test] with additional features:
#
# - Single-argument block design gives a cleaner visual presentation.
# - All script execution is performed in a new stack frame.
# - Script variables are shared across scripts via a temporary namespace.
# - All definition values (except scripts) are [subst]'ed.
#
# The $def argument is a dict which defines the test.  Its possible keys are:
#
# - name | desc
#   Test name and description.
#
# - {scalar name} | {array name}
#   The name component of the key is the name of a scalar or array variable, and
#   the value is the initial scalar value or array dictionary value.  These
#   variables are shared across the setup, body, and cleanup scripts.
#
# - link
#   Uninitialized variables shared across the setup, body, and cleanup scripts.
#
# - setup | body | cleanup
#   The scripts are modified to include variable initialization, linkage, and
#   finalization and to be executed inside new stack frames.
#
# - constraints | result | output | errorOutput | returnCodes | match
#   See tcltest(n) for the purpose of these keys.
proc test {def} {
    # Perform uplevel substitutions, and process scalar and array arguments.
    set scalars {}
    set arrays {}
    dict for {key val} $def {
        if {$key ni {setup body cleanup}} {
            dict set def $key [set val [uplevel [list subst $val]]]
        }
        if {[llength $key] == 2} {
            if {[lindex $key 0] eq "scalar"} {
                dict set scalars [lindex $key 1] $val
                dict unset def $key
            } elseif {[lindex $key 0] eq "array"} {
                dict set arrays [lindex $key 1] $val
                dict unset def $key
            }
        }
    }

    # Augment scripts with variable initialization, linkage, and finalization.
    dict lappend def link {*}[dict keys $scalars] {*}[dict keys $arrays]
    if {[llength [dict get $def link]]} {
        # Ensure all three scripts exist, even if empty.
        foreach key {setup body cleanup} {
            dict append def $key
        }

        # Build variable initialization, linkage, and finalization snippets.
        set initial [list namespace eval ::TestVars [join [list\
            [list variable {*}$scalars]\
            {*}[lmap {var val} $arrays {list variable $var}]\
            {*}[lmap {var val} $arrays {list array set $var $val}]] \n]]
        set linkage [join [lmap var [dict get $def link]\
            {list variable ::TestVars::$var}] \n]
        set final [list namespace delete ::TestVars]

        # Update scripts.
        dict set def setup $initial\n$linkage\n[dict get $def setup]
        dict set def body $linkage\n[dict get $def body]
        dict set def cleanup $linkage\n[dict get $def cleanup]\n$final
    }
    dict unset def link

    # Convert scripts to zero-argument lambda invocations.
    foreach key {setup body cleanup} {
        if {[dict exists $def $key]} {
            dict set def $key [list apply [list {} [dict get $def $key]]]
        }
    }

    # Assemble the Tcltest command.
    set command [list ::tcltest::test [dict get $def name] [dict get $def desc]]
    dict unset def name
    dict unset def desc
    foreach key {constraints setup body cleanup result output errorOutput
            returnCodes match} {
        if {[dict exists $def $key]} {
            lappend command -$key [dict get $def $key]
            dict unset def $key
        }
    }

    # Complain if there are any invalid test definition keys.
    if {[dict size $def]} {
        error "bad test definition key(s): [and [dict keys $def]]"
    }

    # Run the Tcltest command.
    tailcall {*}$command
}

# Formal parameters for each array subcommand.
set params {
    anymore     {arrayName searchId}
    donesearch  {arrayName searchId}
    exists      {arrayName ?mode? ?pattern?}
    get         {arrayName ?mode? ?pattern?}
    names       {arrayName ?mode? ?pattern?}
    nextelement {arrayName searchId}
    set         {arrayName list}
    size        {arrayName ?mode? ?pattern?}
    startsearch {arrayName ?mode? ?pattern?}
    statistics  {arrayName}
    unset       {arrayName ?mode? ?pattern?}
}

# List of array subcommands.
set commands [lsort [dict keys $params]]

# Ambiguous and unambiguous abbreviations of array subcommands.
foreach cmd $commands {
    for {set i 0} {$i < [string length $cmd] - 1} {incr i} {
        set abbrev [string range $cmd 0 $i]
        if {$abbrev in $commands
         || [llength [lsearch -all $commands $abbrev*]] == 1} {
            dict lappend abbrevs $cmd $abbrev
        } else {
            dict set ambig $abbrev {}
        }
    }
}
set ambig [lsort [dict keys $ambig]]

# List of valid array filter mode options.
set modes [lsort {-exact -glob -regexp}]

# array-1.*: subcommand dispatch.
test {
    name array-1.1
    desc {no subcommand}
    body {array}
    returnCodes error
    result {wrong # args: should be "array subcommand ?arg ...?"}
}
test {
    name array-1.2
    desc {empty subcommand}
    body {array {}}
    returnCodes error
    result {unknown or ambiguous subcommand "": must be [or $commands]}
}
test {
    name array-1.3
    desc {invalid subcommand}
    body {array gorp}
    returnCodes error
    result {unknown or ambiguous subcommand "gorp": must be [or $commands]}
}
foreach cmd $ambig {
    test {
        name array-1.4.$cmd
        desc {ambiguous subcommand: \[array $cmd\]}
        {scalar cmd} $cmd
        body {array $cmd}
        returnCodes error
        result {unknown or ambiguous subcommand "$cmd": must be [or $commands]}
    }
}
foreach cmd $commands {
    test {
        name array-1.5.$cmd
        desc {formal parameter lists: \[array $cmd\]}
        {scalar cmd} $cmd
        body {array $cmd}
        returnCodes error
        result {wrong # args: should be "array $cmd [dict get $params $cmd]"}
    }
}

# array-2.*: common argument parsing.
foreach {cmd    code    result} {
    anymore     error   "\"%VAR%\" %MSG%"
    donesearch  error   "\"%VAR%\" %MSG%"
    exists      ok      0
    get         ok      {}
    names       ok      {}
    nextelement error   "\"%VAR%\" %MSG%"
    set         error   "can't set \"%VAR%%ELEM%\": %MSG%"
    size        ok      0
    startsearch error   "\"%VAR%\" %MSG%"
    statistics  error   "\"%VAR%\" %MSG%"
    unset       ok      {}
} {
    test {
        name array-2.1.$cmd
        desc {too many arguments: \[array $cmd\]}
        {scalar cmd} $cmd
        {scalar args} {[lmap param [dict get $params $cmd] {samples $param}]}
        body {array $cmd {*}$args extra}
        returnCodes error
        result {wrong # args: should be "array $cmd [dict get $params $cmd]"}
    }
    if {"?mode?" in [dict get $params $cmd]} {
        test {
            name array-2.2.$cmd
            desc {ambiguous mode: \[array $cmd\]"}
            {scalar cmd} $cmd
            {array a} {}
            body {array $cmd a {} {}}
            returnCodes error
            result {ambiguous option "": must be [or $modes]}
        }
        test {
            name array-2.3.$cmd
            desc {invalid mode: \[array $cmd\]}
            {scalar cmd} $cmd
            {array a} {}
            body {array $cmd a INVALID {}}
            returnCodes error
            result {bad option "INVALID": must be [or $modes]}
        }
        test {
            name array-2.4.$cmd
            desc {invalid regexp: \[array $cmd\]}
            {scalar cmd} $cmd
            {array a} {e 1}
            body {array $cmd a -regexp *}
            returnCodes error
            result {couldn't compile regular expression pattern:\
                quantifier operand invalid}
        }
    }
    test {
        name array-2.5.$cmd
        desc {array trace error during variable lookup: \[array $cmd\]}
        {scalar cmd} $cmd
        {scalar args} {[lmap param [dict get $params $cmd] {samples $param}]}
        link a
        setup {trace add variable a array {apply {{args} {error $args}}}}
        body {array $cmd {*}$args}
        returnCodes error
        result {can't trace array "a": a {} array}
    }
    if {$cmd eq "set"} {
        set nonArray "variable isn't array"
        set nonNamespace "parent namespace doesn't exist"
    } else {
        set nonArray "isn't an array"
        set nonNamespace "isn't an array"
    }
    foreach {
        desc                                skip    setup
        name        msg             var     elem    extra
    } {
        "nonexistent array"                 set     {}
        array-2.6   nonArray        a       {}      {}

        "element of proc-slot-only array"   set     {}
        array-2.7   nonArray        a       {}      {set a(hello) 123}

        "scalar variable"                   {}      {{scalar a} {}}
        array-2.8   nonArray        a       (hello) {}

        "element of empty array"            {}      {{array a} {}}
        array-2.9   nonArray        a(x)    {}      {}

        "element of nonexistent array"      {}      {}
        array-2.10  nonArray        a(x)    {}      {}

        "element of scalar variable"        {}      {{scalar a} {}}
        array-2.11  nonArray        a(x)    {}      {}

        "existing element of array"         {}      {{scalar a} {x 123}}
        array-2.12  nonArray        a(x)    {}      {}

        "nonexistent element of array"      {}      {{array a} {}}
        array-2.13  nonArray        a(x)    {}      {}

        "bad namespace"                     {}      {}
        array-2.14  nonNamespace    ::X::a  {}      {}
    } {
        if {$cmd ni $skip} {
            set map [list %VAR% $var %MSG% [set $msg] %ELEM% $elem]
            test [string map [list %SETUP% $setup %EXTRA% $extra] {
                name $name.$cmd
                desc {$desc: \[array $cmd\]}
                {scalar cmd} $cmd
                {scalar args} {[samples [dict get $params $cmd] arrayName $var]}
                %SETUP%
                body {set result [array $cmd {*}$args]; %EXTRA%; return $result}
                returnCodes $code
                result {[string map $map $result]}
            }]
        }
    }
}

# array-3.*: array set.
test {
    name array-3.1
    desc {empty}
    body {array set a {}; list [array exists a] [array get a]}
    result {1 {}}
}
test {
    name array-3.2
    desc {one array element}
    body {array set a {e 1}; array get a}
    result {e 1}
}
test {
    name array-3.3
    desc {missing value}
    body {array set a e}
    returnCodes error
    result {list must have an even number of elements}
}
test {
    name array-3.4
    desc {duplicate key}
    body {array set a {e 0 e 1}; array get a}
    result {e 1}
}
test {
    name array-3.5
    desc {invalid list}
    body {array set a \{\}x}
    returnCodes error
    result {list element in braces followed by "x" instead of space}
}
test {
    name array-3.6
    desc {invalid list part 2}
    body {array set a \"\"x}
    returnCodes error
    result {list element in quotes followed by "x" instead of space}
}
test {
    name array-3.7
    desc {invalid list part 3}
    body {array set a \{}
    returnCodes error
    result {unmatched open brace in list}
}
test {
    name array-3.8
    desc {invalid list part 4}
    body {array set a \"}
    returnCodes error
    result {unmatched open quote in list}
}
test {
    name array-3.9
    desc {hash order}
    body {array set a {f 2 e 1}; array get a}
    result {e 1 f 2}
}
test {
    name array-3.10
    desc {adding elements}
    body {array set a {f 2}; array set a {e 1}; array get a}
    result {e 1 f 2}
}
test {
    name array-3.11
    desc {adding elements, hash order}
    body {array set a {e 1}; array set a {f 2}; array get a}
    result {e 1 f 2}
}
test {
    name array-3.12
    desc {replacing elements}
    body {array set a {e 1}; array set a {e 2}; array get a}
    result {e 2}
}
test {
    name array-3.13
    desc {adding and replacing elements}
    body {array set a {e 1}; array set a {f 3 e 2}; array get a}
    result {e 2 f 3}
}
test {
    name array-3.14
    desc {former scalar}
    {scalar a} xxx
    body {unset a; array set a {e 1}; array get a}
    result {e 1}
}
test {
    name array-3.15
    desc {weird names}
    body {array set a {{ a  b } 1 ) 2 ( 3 )( 4 () 5 {} 6}; array get a}
    result {{} 6 ( 3 () 5 )( 4 ) 2 { a  b } 1}
}

# array-4.*: array size.
test {
    name array-4.1
    desc {empty array}
    {array a} {}
    body {array size a}
    result 0
}
test {
    name array-4.2
    desc {single-element array}
    {array a} {e 1}
    body {array size a}
    result 1
}
test {
    name array-4.3
    desc {thousand-element array}
    body {for {set i 0} {$i < 1000} {incr i} {set a($i) $i}; array size a}
    result 1000
}
test {
    name array-4.4
    desc {increasing array size}
    {array a} {e 1}
    body {list [array size a] [set a(f) {}] [array size a]}
    result {1 {} 2}
}
test {
    name array-4.5
    desc {decrasing array size}
    {array a} {e 1 f 2}
    body {list [array size a] [unset a(f)] [array size a]}
    result {2 {} 1}
}

# array-5.*: array unset.
test {
    name array-5.1
    desc {unset non-empty array}
    {array a} {e 1}
    body {array unset a; info exists a}
    result 0
}

# Cleanup.
foreach namespace [namespace children] {
    if {$namespace ni $namespaces} {
        namespace delete $namespace
    }
}
foreach proc [info procs] {
    if {$proc ni $procs} {
        rename $proc {}
    }
}
foreach var [info vars] {
    if {$var ne "vars" && $var ni $vars} {
        unset $var
    }
}
unset -nocomplain var vars
::tcltest::cleanupTests
return

# vim: set sts=4 sw=4 tw=80 et ft=tcl:
# Local Variables:
# mode: tcl
# End:
