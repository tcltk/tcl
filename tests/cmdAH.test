# The file tests the tclCmdAH.c file.
#
# This file contains a collection of tests for one or more of the Tcl built-in
# commands. Sourcing this file into Tcl runs the tests and generates output
# for errors. No output means no errors were found.
#
# Copyright © 1996-1998 Sun Microsystems, Inc.
# Copyright © 1998-1999 Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution of
# this file, and for a DISCLAIMER OF ALL WARRANTIES.

if {"::tcltest" ni [namespace children]} {
    package require tcltest 2.5
    namespace import -force ::tcltest::*
}

::tcltest::loadTestedCommands
catch [list package require -exact tcl::test [info patchlevel]]

testConstraint testchmod       [llength [info commands testchmod]]
testConstraint testsetplatform [llength [info commands testsetplatform]]
testConstraint testvolumetype  [llength [info commands testvolumetype]]
testConstraint testbytestring [llength [info commands testbytestring]]
testConstraint time64bit [expr {
    $::tcl_platform(pointerSize) >= 8 ||
    [llength [info command testsize]] && [testsize st_mtime] >= 8
}]
testConstraint linkDirectory [expr {
    ![testConstraint win] ||
    ($::tcl_platform(osVersion) >= 5.0
     && [lindex [file system [temporaryDirectory]] 1] eq "NTFS")
}]
testConstraint notWine [expr {![info exists ::env(CI_USING_WINE)]}]

global env
set cmdAHwd [pwd]
catch {set platform [testgetplatform]}

proc waitForEvenSecondForFAT {} {
    # Windows 9x uses filesystems (the FAT* family of FSes) without enough
    # data in its timestamps for even per-second-accurate timings. :^(
    # This procedure based on work by Helmut Giese
    if {
	[testConstraint win] &&
	[lindex [file system [temporaryDirectory]] 1] ne "NTFS"
    } then {
	# Assume non-NTFS means FAT{12,16,32} and hence in need of special
	# help...
	set start [clock seconds]
	while {1} {
	    set now [clock seconds]
	    if {$now!=$start && !($now & 1)} {
		break
	    }
	    after 50
	}
    }
}

test cmdAH-0.1 {Tcl_BreakObjCmd, errors} -body {
    break foo
} -returnCodes error -result {wrong # args: should be "break"}
test cmdAH-0.2 {Tcl_BreakObjCmd, success} {
    list [catch {break} msg] $msg
} {3 {}}

# Tcl_CaseObjCmd is tested in case.test

test cmdAH-1.1 {Tcl_CatchObjCmd, errors} -returnCodes error -body {
    catch
} -result {wrong # args: should be "catch script ?resultVarName? ?optionVarName?"}
test cmdAH-1.2 {Tcl_CatchObjCmd, errors} {
    list [catch {catch foo bar baz} msg] $msg
} {0 1}
test cmdAH-1.3 {Tcl_CatchObjCmd, errors} -returnCodes error -body {
    catch foo bar baz spaz
} -result {wrong # args: should be "catch script ?resultVarName? ?optionVarName?"}
test cmdAH-1.4 {Bug 3595576} {
    catch {catch {} -> noSuchNs::var}
} 1
test cmdAH-1.5 {Bug 3595576} {
    catch {catch error -> noSuchNs::var}
} 1

test cmdAH-2.1 {Tcl_CdObjCmd} -returnCodes error -body {
    cd foo bar
} -result {wrong # args: should be "cd ?dirName?"}
set foodir [file join [temporaryDirectory] foo]
test cmdAH-2.2 {Tcl_CdObjCmd} -setup {
    file delete -force $foodir
    set oldpwd [pwd]
} -body {
    file mkdir $foodir
    cd $foodir
    file tail [pwd]
} -cleanup {
    cd $oldpwd
    file delete $foodir
} -result foo
test cmdAH-2.3 {Tcl_CdObjCmd} -setup {
    global env
    set oldpwd [pwd]
    set temp $env(HOME)
    file delete -force $foodir
} -body {
    set env(HOME) $oldpwd
    file mkdir $foodir
    cd $foodir
    cd ~
    string equal [pwd] $oldpwd
} -cleanup {
    cd $oldpwd
    file delete $foodir
    set env(HOME) $temp
} -result 1
test cmdAH-2.4 {Tcl_CdObjCmd} -setup {
    global env
    set oldpwd [pwd]
    set temp $env(HOME)
    file delete -force $foodir
} -body {
    set env(HOME) $oldpwd
    file mkdir $foodir
    cd $foodir
    cd
    string equal [pwd] $oldpwd
} -cleanup {
    cd $oldpwd
    file delete $foodir
    set env(HOME) $temp
} -result 1
test cmdAH-2.5 {Tcl_CdObjCmd} -returnCodes error -body {
    cd ~~
} -result {user "~" doesn't exist}
test cmdAH-2.6 {Tcl_CdObjCmd} -returnCodes error -body {
    cd _foobar
} -result {couldn't change working directory to "_foobar": no such file or directory}
test cmdAH-2.6.1 {Tcl_CdObjCmd} -returnCodes error -body {
    cd ""
} -result {couldn't change working directory to "": no such file or directory}
test cmdAH-2.6.2 {cd} -constraints {unix nonPortable} -setup {
    set dir [pwd]
} -body {
    cd /
    pwd
} -cleanup {
    cd $dir
} -result {/}
test cmdAH-2.6.3 {Tcl_CdObjCmd, bug #3118489} -setup {
    set dir [pwd]
} -returnCodes error -body {
    cd .\x00
} -cleanup {
    cd $dir
} -match glob -result "couldn't change working directory to \".\x00\": *"
test cmdAH-2.7 {Tcl_ConcatObjCmd} {
    concat
} {}
test cmdAH-2.8 {Tcl_ConcatObjCmd} {
    concat a
} a
test cmdAH-2.9 {Tcl_ConcatObjCmd} {
    concat a {b c}
} {a b c}

test cmdAH-3.1 {Tcl_ContinueObjCmd, errors} -returnCodes error -body {
    continue foo
} -result {wrong # args: should be "continue"}
test cmdAH-3.2 {Tcl_ContinueObjCmd, success} {
    list [catch {continue} msg] $msg
} {4 {}}

###
# encoding command

set "numargErrors(encoding system)" {^wrong # args: should be "(encoding |::tcl::encoding::)system \?encoding\?"$}
set "numargErrors(encoding convertfrom)" {^wrong # args: should be "(encoding |::tcl::encoding::)convertfrom \?\?-profile profile\? \?-failindex var\? \?encoding\?\? data"$}
set "numargErrors(encoding convertto)" {^wrong # args: should be "(encoding |::tcl::encoding::)convertto \?\?-profile profile\? \?-failindex var\? \?encoding\?\? data"$}
set "numargErrors(encoding names)" {wrong # args: should be "encoding names"}
set "numargErrors(encoding profiles)" {wrong # args: should be "encoding profiles"}

set encProfiles {tcl8 strict replace}
set encDefaultProfile tcl8; # Should reflect the default from implementation

# TODO - valid sequences for different encodings - shiftjis etc.
# Note utf-16, utf-32 missing because they are automatically
# generated based on le/be versions. Also add all ranges from Unicode standard
# Table 3.7
set encValidStrings {
    ascii    ABC                           414243
    utf-8    A\u0000\u03A9\u8A9E\U00010384 4100CEA9E8AA9EF0908E84
    utf-16le A\u0000\u03A9\u8A9E\U00010384 41000000A9039E8A00D884DF
    utf-16be A\u0000\u03A9\u8A9E\U00010384 0041000003A98A9ED800DF84
    utf-32le A\u0000\u03A9\u8A9E\U00010384 4100000000000000A90300009E8A000084030100
    utf-32be A\u0000\u03A9\u8A9E\U00010384 0000004100000000000003A900008A9E00010384
}

# Invalid byte sequences. These are driven from a table with format
#    {encoding bytes profile expectedresult expectedfailindex ctrl comment}
#
# <enc,bytes,profile> should be unique for test ids to be unique. Note utf-16,
# utf-32 missing because they are automatically generated based on le/be
# versions. Each entry potentially results in generation of multiple tests.
# This is controlled by the ctrl field. This should be a list of
# zero or more of the following:
#   solo - the test data is the string itself
#   lead - the test data is the string followed by a valid suffix
#   tail - the test data is the string preceded by a prefix
#   middle - the test data is the string wrapped by a prefix and suffix
# If the ctrl field is empty it is treated as all of the above
# Note if there is any other value by itself, it will cause the test to
# be skipped. This is intentional to skip known bugs.

# TODO - other encodings and test cases

# ascii - Any byte above 127 is invalid and is mapped
# to the same numeric code point except for the range
# 80-9F which is treated as cp1252.
# This tests the TableToUtfProc code path.
lappend encInvalidBytes {*}{
    ascii 80 tcl8    \u20AC -1 {knownBug} {map to cp1252}
    ascii 80 replace \uFFFD -1 {} {Smallest invalid byte}
    ascii 80 strict  {}      0 {} {Smallest invalid byte}
    ascii 81 tcl8    \u0081 -1 {knownBug} {map to cp1252}
    ascii 82 tcl8    \u201A -1 {knownBug} {map to cp1252}
    ascii 83 tcl8    \u0192 -1 {knownBug} {map to cp1252}
    ascii 84 tcl8    \u201E -1 {knownBug} {map to cp1252}
    ascii 85 tcl8    \u2026 -1 {knownBug} {map to cp1252}
    ascii 86 tcl8    \u2020 -1 {knownBug} {map to cp1252}
    ascii 87 tcl8    \u2021 -1 {knownBug} {map to cp1252}
    ascii 88 tcl8    \u0276 -1 {knownBug} {map to cp1252}
    ascii 89 tcl8    \u2030 -1 {knownBug} {map to cp1252}
    ascii 8A tcl8    \u0160 -1 {knownBug} {map to cp1252}
    ascii 8B tcl8    \u2039 -1 {knownBug} {map to cp1252}
    ascii 8C tcl8    \u0152 -1 {knownBug} {map to cp1252}
    ascii 8D tcl8    \u008D -1 {knownBug} {map to cp1252}
    ascii 8E tcl8    \u017D -1 {knownBug} {map to cp1252}
    ascii 8F tcl8    \u008F -1 {knownBug} {map to cp1252}
    ascii 90 tcl8    \u0090 -1 {knownBug} {map to cp1252}
    ascii 91 tcl8    \u2018 -1 {knownBug} {map to cp1252}
    ascii 92 tcl8    \u2019 -1 {knownBug} {map to cp1252}
    ascii 93 tcl8    \u201C -1 {knownBug} {map to cp1252}
    ascii 94 tcl8    \u201D -1 {knownBug} {map to cp1252}
    ascii 95 tcl8    \u2022 -1 {knownBug} {map to cp1252}
    ascii 96 tcl8    \u2013 -1 {knownBug} {map to cp1252}
    ascii 97 tcl8    \u2014 -1 {knownBug} {map to cp1252}
    ascii 98 tcl8    \u02DC -1 {knownBug} {map to cp1252}
    ascii 99 tcl8    \u2122 -1 {knownBug} {map to cp1252}
    ascii 9A tcl8    \u0161 -1 {knownBug} {map to cp1252}
    ascii 9B tcl8    \u203A -1 {knownBug} {map to cp1252}
    ascii 9C tcl8    \u0153 -1 {knownBug} {map to cp1252}
    ascii 9D tcl8    \u009D -1 {knownBug} {map to cp1252}
    ascii 9E tcl8    \u017E -1 {knownBug} {map to cp1252}
    ascii 9F tcl8    \u0178 -1 {knownBug} {map to cp1252}

    ascii FF tcl8    \u00FF -1 {} {Largest invalid byte}
    ascii FF replace \uFFFD -1 {} {Largest invalid byte}
    ascii FF strict  {}      0 {} {Largest invalid byte}
}

# utf-8 - valid sequences based on Table 3.7 in the Unicode
# standard.
#
# Code Points        First   Second  Third   Fourth Byte
# U+0000..U+007F     00..7F
# U+0080..U+07FF     C2..DF  80..BF
# U+0800..U+0FFF     E0      A0..BF  80..BF
# U+1000..U+CFFF     E1..EC  80..BF  80..BF
# U+D000..U+D7FF     ED      80..9F  80..BF
# U+E000..U+FFFF     EE..EF  80..BF  80..BF
# U+10000..U+3FFFF   F0      90..BF  80..BF  80..BF
# U+40000..U+FFFFF   F1..F3  80..BF  80..BF  80..BF
# U+100000..U+10FFFF F4      80..8F  80..BF  80..BF
#
# Tests below are based on the "gaps" in the above table. Note ascii test
# values are repeated because internally a different code path is used
# (UtfToUtfProc).
# Note C0, C1, F5:FF are invalid bytes ANYWHERE. Exception is C080
lappend encInvalidBytes {*}{
    utf-8 80 tcl8    \u20AC -1 {knownBug} {map to cp1252}
    utf-8 80 tcl8    \u20AC -1 {knownBug} {map to cp1252}
    utf-8 80 replace \uFFFD -1 {} {Smallest invalid byte}
    utf-8 80 strict  {}      0 {} {Smallest invalid byte}
    utf-8 81 tcl8    \u0081 -1 {knownBug} {map to cp1252}
    utf-8 82 tcl8    \u201A -1 {knownBug} {map to cp1252}
    utf-8 83 tcl8    \u0192 -1 {knownBug} {map to cp1252}
    utf-8 84 tcl8    \u201E -1 {knownBug} {map to cp1252}
    utf-8 85 tcl8    \u2026 -1 {knownBug} {map to cp1252}
    utf-8 86 tcl8    \u2020 -1 {knownBug} {map to cp1252}
    utf-8 87 tcl8    \u2021 -1 {knownBug} {map to cp1252}
    utf-8 88 tcl8    \u0276 -1 {knownBug} {map to cp1252}
    utf-8 89 tcl8    \u2030 -1 {knownBug} {map to cp1252}
    utf-8 8A tcl8    \u0160 -1 {knownBug} {map to cp1252}
    utf-8 8B tcl8    \u2039 -1 {knownBug} {map to cp1252}
    utf-8 8C tcl8    \u0152 -1 {knownBug} {map to cp1252}
    utf-8 8D tcl8    \u008D -1 {knownBug} {map to cp1252}
    utf-8 8E tcl8    \u017D -1 {knownBug} {map to cp1252}
    utf-8 8F tcl8    \u008F -1 {knownBug} {map to cp1252}
    utf-8 90 tcl8    \u0090 -1 {knownBug} {map to cp1252}
    utf-8 91 tcl8    \u2018 -1 {knownBug} {map to cp1252}
    utf-8 92 tcl8    \u2019 -1 {knownBug} {map to cp1252}
    utf-8 93 tcl8    \u201C -1 {knownBug} {map to cp1252}
    utf-8 94 tcl8    \u201D -1 {knownBug} {map to cp1252}
    utf-8 95 tcl8    \u2022 -1 {knownBug} {map to cp1252}
    utf-8 96 tcl8    \u2013 -1 {knownBug} {map to cp1252}
    utf-8 97 tcl8    \u2014 -1 {knownBug} {map to cp1252}
    utf-8 98 tcl8    \u02DC -1 {knownBug} {map to cp1252}
    utf-8 99 tcl8    \u2122 -1 {knownBug} {map to cp1252}
    utf-8 9A tcl8    \u0161 -1 {knownBug} {map to cp1252}
    utf-8 9B tcl8    \u203A -1 {knownBug} {map to cp1252}
    utf-8 9C tcl8    \u0153 -1 {knownBug} {map to cp1252}
    utf-8 9D tcl8    \u009D -1 {knownBug} {map to cp1252}
    utf-8 9E tcl8    \u017E -1 {knownBug} {map to cp1252}
    utf-8 9F tcl8    \u0178 -1 {knownBug} {map to cp1252}

    utf-8 C0 tcl8    \u00C0 -1 {} {C0 is invalid anywhere}
    utf-8 C0 strict  {}      0 {} {C0 is invalid anywhere}
    utf-8 C0 replace \uFFFD -1 {} {C0 is invalid anywhere}
    utf-8 C080 tcl8    \u0000 -1 {} {C080 -> U+0 in Tcl's internal modified UTF8}
    utf-8 C080 strict  {}      0 {} {C080 -> invalid}
    utf-8 C080 replace \uFFFD -1 {} {C080 -> single replacement char}
    utf-8 C1 tcl8    \u00C1 -1 {} {C1 is invalid everywhere}
    utf-8 C1 replace \uFFFD -1 {} {C1 is invalid everywhere}
    utf-8 C1 strict  {}      0 {} {C1 is invalid everywhere}

    utf-8 C2 tcl8      \u00C2     -1 {} {Missing trail byte}
    utf-8 C2 replace   \uFFFD     -1 {} {Missing trail byte}
    utf-8 C2 strict    {}          0 {} {Missing trail byte}
    utf-8 C27F tcl8    \u00C2\x7F -1 {} {Trail byte must be 80:BF}
    utf-8 C27F replace \uFFFD\x7F -1 {} {Trail byte must be 80:BF}
    utf-8 C27F strict  {}          0 {} {Trail byte must be 80:BF}
    utf-8 DF tcl8      \u00DF     -1 {} {Missing trail byte}
    utf-8 DF replace   \uFFFD     -1 {} {Missing trail byte}
    utf-8 DF strict    {}          0 {} {Missing trail byte}
    utf-8 DF7F tcl8    \u00DF\x7F -1 {} {Trail byte must be 80:BF}
    utf-8 DF7F replace \uFFFD\x7F -1 {} {Trail byte must be 80:BF}
    utf-8 DF7F strict  {}          0 {} {Trail byte must be 80:BF}
    utf-8 DFE0A080 tcl8    \u00DF\u0800 -1 {} {Invalid trail byte is start of valid sequence}
    utf-8 DFE0A080 replace \uFFFD\u0800 -1 {} {Invalid trail byte is start of valid sequence}
    utf-8 DFE0A080 strict  {}            0 {} {Invalid trail byte is start of valid sequence}

    utf-8 E0 tcl8      \u00E0     -1 {} {Missing trail byte}
    utf-8 E0 replace   \uFFFD     -1 {} {Missing trail byte}
    utf-8 E0 strict    {}          0 {} {Missing trail byte}
    utf-8 E080 tcl8      \u00E0\u20AC   -1 {knownBug} {First trail byte must be A0:BF}
    utf-8 E080 replace   \uFFFD\uFFFD   -1 {}         {First trail byte must be A0:BF}
    utf-8 E080 strict    {}              0 {}         {First trail byte must be A0:BF}
    utf-8 E09F tcl8      \u00E0\u0178   -1 {knownBug} {First trail byte must be A0:BF}
    utf-8 E09F replace   \uFFFD\uFFFD   -1 {}         {First trail byte must be A0:BF}
    utf-8 E09F strict    {}              0 {}         {First trail byte must be A0:BF}
    utf-8 E0A07F tcl8    \u00E0\u00A0\x7F   -1 {}     {Second trail byte must be 80:BF}
    utf-8 E0A07F replace \uFFFD\u7F         -1 {knownW3C} {Second trail byte must be 80:BF}
    utf-8 E0A07F strict  {}                  0 {}         {Second trail byte must be 80:BF}
    utf-8 E0BF7F tcl8    \u00E0\u00BF\x7F   -1 {}         {Second trail byte must be 80:BF}
    utf-8 E0BF7F replace \uFFFD\u7F         -1 {knownW3C} {Second trail byte must be 80:BF}
    utf-8 E0BF7F strict  {}                  0 {}         {Second trail byte must be 80:BF}

    utf-8 E1 tcl8      \u00E1     -1 {} {Missing trail byte}
    utf-8 E1 replace   \uFFFD     -1 {} {Missing trail byte}
    utf-8 E1 strict    {}          0 {} {Missing trail byte}
    utf-8 E17F tcl8    \u00E1\x7F -1 {} {Trail byte must be 80:BF}
    utf-8 E17F replace \uFFFD\x7F -1 {} {Trail byte must be 80:BF}
    utf-8 E17F strict  {}          0 {} {Trail byte must be 80:BF}
    utf-8 E1807F tcl8    \u00E1\u20AC\x7F   -1 {knownBug} {Second trail byte must be 80:BF}
    utf-8 E1807F replace \uFFFD\u7F         -1 {knownW3C} {Second trail byte must be 80:BF}
    utf-8 E1807F strict  {}                  0 {}         {Second trail byte must be 80:BF}
    utf-8 E1BF7F tcl8    \u00E1\u00BF\x7F   -1 {}         {Second trail byte must be 80:BF}
    utf-8 E1BF7F replace \uFFFD\u7F         -1 {knownW3C} {Second trail byte must be 80:BF}
    utf-8 E1BF7F strict  {}                  0 {}         {Second trail byte must be 80:BF}
    utf-8 EC tcl8      \u00EC     -1 {} {Missing trail byte}
    utf-8 EC replace   \uFFFD     -1 {} {Missing trail byte}
    utf-8 EC strict    {}          0 {} {Missing trail byte}
    utf-8 EC7F tcl8    \u00EC\x7F -1 {} {Trail byte must be 80:BF}
    utf-8 EC7F replace \uFFFD\x7F -1 {} {Trail byte must be 80:BF}
    utf-8 EC7F strict  {}          0 {} {Trail byte must be 80:BF}
    utf-8 EC807F tcl8    \u00EC\u20AC\x7F   -1 {knownBug} {Second trail byte must be 80:BF}
    utf-8 EC807F replace \uFFFD\u7F         -1 {knownW3C} {Second trail byte must be 80:BF}
    utf-8 EC807F strict  {}                  0 {}         {Second trail byte must be 80:BF}
    utf-8 ECBF7F tcl8    \u00EC\u00BF\x7F   -1 {}         {Second trail byte must be 80:BF}
    utf-8 ECBF7F replace \uFFFD\u7F         -1 {knownW3C} {Second trail byte must be 80:BF}
    utf-8 ECBF7F strict  {}                  0 {}         {Second trail byte must be 80:BF}

    utf-8 ED tcl8      \u00ED     -1 {} {Missing trail byte}
    utf-8 ED replace   \uFFFD     -1 {} {Missing trail byte}
    utf-8 ED strict    {}          0 {} {Missing trail byte}
    utf-8 ED7F tcl8      \u00ED\u7F   -1 {knownBug} {First trail byte must be 80:9F}
    utf-8 ED7F replace   \uFFFD\u7F   -1 {}         {First trail byte must be 80:9F}
    utf-8 ED7F strict    {}              0 {}         {First trail byte must be 80:9F}
    utf-8 EDA0 tcl8      \u00ED\u00A0   -1 {knownBug} {First trail byte must be 80:9F}
    utf-8 EDA0 replace   \uFFFD\uFFFD   -1 {}         {First trail byte must be 80:9F}
    utf-8 EDA0 strict    {}              0 {}         {First trail byte must be 80:9F}
    utf-8 ED807F tcl8    \u00ED\u20AC\x7F   -1 {knownBug} {Second trail byte must be 80:BF}
    utf-8 ED807F replace \uFFFD\u7F         -1 {knownW3C} {Second trail byte must be 80:BF}
    utf-8 ED807F strict  {}                  0 {}         {Second trail byte must be 80:BF}
    utf-8 ED9F7F tcl8    \u00ED\u0178\x7F   -1 {knownBug} {Second trail byte must be 80:BF}
    utf-8 ED9F7F replace \uFFFD\u7F         -1 {knownW3C} {Second trail byte must be 80:BF}
    utf-8 ED9F7F strict  {}                  0 {}         {Second trail byte must be 80:BF}
    utf-8 EDA080 tcl8       \uD800             -1 {}         {High surrogate}
    utf-8 EDA080 replace    \uFFFD             -1 {}         {High surrogate}
    utf-8 EDA080 strict     {}                  0 {}         {High surrogate}
    utf-8 EDAFBF tcl8       \uDBFF             -1 {}         {High surrogate}
    utf-8 EDAFBF replace    \uFFFD             -1 {}         {High surrogate}
    utf-8 EDAFBF strict     {}                  0 {}         {High surrogate}
    utf-8 EDB080 tcl8       \uDC00             -1 {}         {Low surrogate}
    utf-8 EDB080 replace    \uFFFD             -1 {}         {Low surrogate}
    utf-8 EDB080 strict     {}                  0 {}         {Low surrogate}
    utf-8 EDBFBF tcl8       \uDFFF             -1 {}         {Low surrogate}
    utf-8 EDBFBF replace    \uFFFD             -1 {}         {Low surrogate}
    utf-8 EDBFBF strict     {}                  0 {}         {Low surrogate}
    utf-8 EDA080EDB080 tcl8 \U00010000         -1 {}         {High low surrogate pair}
    utf-8 EDA080EDB080 replace \uFFFD\uFFFD         -1 {}         {High low surrogate pair}
    utf-8 EDA080EDB080 strict {}         0 {}         {High low surrogate pair}
    utf-8 EDAFBFEDBFBF tcl8 \U0010FFFF           -1 {}         {High low surrogate pair}
    utf-8 EDAFBFEDBFBF replace \uFFFD\uFFFD           -1 {}         {High low surrogate pair}
    utf-8 EDAFBFEDBFBF strict {}           0 {}         {High low surrogate pair}

    utf-8 F5 tcl8    \u00F5 -1 {} {F5:FF are invalid everywhere}
    utf-8 F5 replace \uFFFD -1 {} {F5:FF are invalid everywhere}
    utf-8 F5 strict  {}      0 {} {F5:FF are invalid everywhere}
    utf-8 FF tcl8    \u00FF -1 {} {F5:FF are invalid everywhere}
    utf-8 FF replace \uFFFD -1 {} {F5:FF are invalid everywhere}
    utf-8 FF strict  {}      0 {} {F5:FF are invalid everywhere}

    utf-8 C0AFE080BFF0818130 replace \uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\x30 -1 {} {Unicode Table 3-8}
    utf-8 EDA080EDBFBFEDAF30 replace \uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\x30 -1 {knownW3C} {Unicode Table 3-9}
    utf-8 F4919293FF4180BF30 replace \uFFFD\uFFFD\uFFFD\uFFFD\uFFFD\u0041\uFFFD\uFFFD\x30 -1 {} {Unicode Table 3-10}
    utf-8 E180E2F09192F1BF30 replace \uFFFD\uFFFD\uFFFD\uFFFD\x30                         -1 {knownW3C} {Unicode Table 3.11}
}

set xxencInvalidBytes {
    
    utf-8 \x41\x80\x42     tcl8      A\u0080B -1 80
    utf-8 \x41\x80\x42     replace   A\uFFFDB -1 80
    utf-8 \x41\x80\x42     strict    A         1 80
    utf-8 \x41\xC0\x80\x42 tcl8      A\u0000B -1 C080
    utf-8 \x41\xC0\x80\x42 strict    A         1 C080
    utf-8 \x41\xC1\x42     tcl8      A\u00C1B -1 C1
    utf-8 \x41\xC1\x42     replace   A\uFFFDB -1 C1
    utf-8 \x41\xC1\x42     strict    A         1 C1
    utf-8 \x41\xC2\x42     tcl8      A\u00C2B -1 C2-nontrail
    utf-8 \x41\xC2\x42     replace   A\uFFFDB -1 C2-nontrail
    utf-8 \x41\xC2\x42     strict    A         1 C2-nontrail
    utf-8 \x41\xC2         tcl8      A\u00C2  -1 C2-incomplete
    utf-8 \x41\xC2         replace   A\uFFFD  -1 C2-incomplete
    utf-8 \x41\xC2         strict    A         1 C2-incomplete
    utf-8 A\xed\xa0\x80B   tcl8      A\uD800B -1 High-surrogate
    utf-8 A\xed\xa0\x80B   strict    A         1 High-surrogate
    utf-8 A\xed\xb0\x80B   tcl8      A\uDC00B -1 Low-surrogate
    utf-8 A\xed\xb0\x80B   strict    A         1 Low-surrogate
    utf-8 \xed\xa0\x80\xed\xb0\x80   tcl8      \U00010000 -1 High-low-surrogate
    utf-8 \xed\xa0\x80\xed\xb0\x80   strict    {}          0 High-low-surrogate
}
set utf32-le-TODO {
    utf-32le \x00\xD8\x00\x00                                   tcl8     \uD800   -1 {High-surrogate}
    utf-32le \x00\xD8\x00\x00                                   strict   ""        0 {High-surrogate}
    utf-32le \x00\xDC\x00\x00                                   tcl8     \uDC00   -1 {Low-surrogate}
    utf-32le \x00\xDC\x00\x00                                   strict   ""        0 {Low-surrogate}
    utf-32le \x00\xD8\x00\x00\x00\xDC\x00\x00                   tcl8     \uD800\uDC00  -1 {High-low-surrogate}
    utf-32le \x00\xD8\x00\x00\x00\xDC\x00\x00                   strict   ""             0 {High-low-surrogate}
    utf-32le \x00\xDC\x00\x00\x00\xD8\x00\x00                   tcl8     \uDC00\uD800  -1 {High-low-surrogate}
    utf-32le \x00\xDC\x00\x00\x00\xD8\x00\x00                   strict   ""             0 {High-low-surrogate}
    utf-32le \x41\x00\x00\x00\x00\xD8\x00\x00\x42\x00\x00\x00   tcl8     A\uD800B -1 {High-surrogate-middle}
    utf-32le \x41\x00\x00\x00\x00\xD8\x00\x00\x42\x00\x00\x00   strict   A         4 {High-surrogate-middle}
}

# Strings that cannot be encoded for specific encoding / profiles
# {encoding string profile exptedresult expectedfailindex ctrl comment}
# <enc,string,profile> should be unique for test ids to be unique.
# Note utf-16, utf-32 missing because they are automatically
# generated based on le/be versions.
# Each entry potentially results in generation of multiple tests.
# This is controlled by the ctrl field. This should be a list of
# zero or more of the following:
#   solo - the test data is the string itself
#   lead - the test data is the string followed by a valid suffix
#   tail - the test data is the string preceded by a prefix
#   middle - the test data is the string wrapped by a prefix and suffix
# If the ctrl field is empty it is treated as all of the above
# Note if there is any other value by itself, it will cause the test to
# be skipped. This is intentional to skip known bugs.
# TODO - other encodings and test cases
# TODO - out of range code point (note cannot be generated by \U notation)
set encUnencodableStrings {
    ascii \u00e0 tcl8    3f -1 {} {unencodable}
    ascii \u00e0 strict  {}  0 {} {unencodable}

    iso8859-1 \u0141 tcl8    3f -1 {} unencodable
    iso8859-1 \u0141 strict  {}  0 {} unencodable

    utf-8 \uD800 tcl8    eda080 -1 {} High-surrogate
    utf-8 \uD800 strict  {}      0 {} High-surrogate
    utf-8 \uDC00 tcl8    edb080 -1 {} High-surrogate
    utf-8 \uDC00 strict  {}      0 {} High-surrogate
}

if {$::tcl_platform(byteOrder) eq "littleEndian"} {
    set endian le
} else {
    set endian be
}

# Maps utf-{16,32}{le,be} to utf-16, utf-32 and
# others to "". Used to test utf-16, utf-32 based
# on system endianness
proc endianUtf {enc} {
    if {$::tcl_platform(byteOrder) eq "littleEndian"} {
        set endian le
    } else {
        set endian be
    }
    if {$enc eq "utf-16$endian" || $enc eq "utf-32$endian"} {
        return [string range $enc 0 5]
    }
    return ""
}

# Map arbitrary strings to printable form in ASCII.
proc printable {s} {
    set print ""
    foreach c [split $s ""] {
        set i [scan $c %c]
        if {[string is print $c] && ($i <= 127)} {
            append print $c
        } elseif {$i <= 0xff} {
            append print \\x[format %02X $i]
        } elseif {$i <= 0xffff} {
            append print \\u[format %04X $i]
        } else {
            append print \\U[format %08X $i]
        }
    }
    return $print
}

#
# Check errors for invalid number of arguments
proc badnumargs {id cmd cmdargs} {
    variable numargErrors
    test $id.a "Syntax error: $cmd $cmdargs" \
        -body [list {*}$cmd {*}$cmdargs] \
        -result $numargErrors($cmd) \
        -match regexp \
        -returnCodes error
    test $id.b "Syntax error: $cmd (byte compiled)" \
        -setup [list proc compiled_proc {} [list {*}$cmd {*}$cmdargs]] \
        -body {compiled_proc} \
        -cleanup {rename compiled_proc {}} \
        -result $numargErrors($cmd) \
        -match regexp \
        -returnCodes error
}

# Wraps tests resulting in unknown encoding errors
proc unknownencodingtest {id cmd} {
    set result "unknown encoding \"[lindex $cmd end-1]\""
    test $id.a "Unknown encoding error: $cmd" \
        -body [list encoding {*}$cmd] \
        -result $result \
        -returnCodes error
    test $id.b "Syntax error: $cmd (byte compiled)" \
        -setup [list proc encoding_test {} [list encoding {*}$cmd]] \
        -body {encoding_test} \
        -cleanup {rename encoding_test {}} \
        -result $result \
        -returnCodes error
}

# Wraps tests for conversion, successful or not.
# Really more general than just for encoding conversion.
proc testconvert {id body result args} {
    test $id.a $body \
        -body $body \
        -result $result \
        {*}$args
    dict append args -setup \n[list proc compiled_script {} $body]
    dict append args -cleanup "\nrename compiled_script {}"
    test $id.b "$body (byte compiled)" \
        -body {compiled_script} \
        -result $result \
        {*}$args
}

# Wrapper to verify encoding convert{to,from} ?-profile?
# Generates tests for compiled and uncompiled implementation.
# Also generates utf-{16,32} tests if passed encoding is utf-{16,32}{le,be}
# The enc and profile are appended to id to generate the test id
proc testprofile {id converter enc profile data result args} {
    testconvert $id.$enc.$profile [list encoding $converter -profile $profile $enc $data] $result {*}$args
    if {[set enc2 [endianUtf $enc]] ne ""} {
        # If utf{16,32}-{le,be}, also do utf{16,32}
        testconvert $id.$enc2.$profile [list encoding $converter -profile $profile $enc2 $data] $result {*}$args
    }

    # If this is the default profile, generate a test without specifying profile
    if {$profile eq $::encDefaultProfile} {
        testconvert $id.$enc.default [list encoding $converter $enc $data] $result {*}$args
        if {[set enc2 [endianUtf $enc]] ne ""} {
            # If utf{16,32}-{le,be}, also do utf{16,32}
            testconvert $id.$enc2.default [list encoding $converter $enc2 $data] $result {*}$args
        }
    }
}


# Wrapper to verify encoding convert{to,from} -failindex ?-profile?
# Generates tests for compiled and uncompiled implementation.
# Also generates utf-{16,32} tests if passed encoding is utf-{16,32}{le,be}
# The enc and profile are appended to id to generate the test id
proc testfailindex {id converter enc data result {profile default}} {
    testconvert $id.$enc.$profile "list \[encoding $converter -profile $profile -failindex idx $enc $data] \[set idx]" $result
    if {[set enc2 [endianUtf $enc]] ne ""} {
        # If utf{16,32}-{le,be}, also do utf{16,32}
        testconvert $id.$enc2.$profile "list \[encoding $converter -profile $profile -failindex idx $enc2 $data] \[set idx]" $result
    }

    # If this is the default profile, generate a test without specifying profile
    if {$profile eq $::encDefaultProfile} {
        testconvert $id.$enc.default "list \[encoding $converter -failindex idx $enc $data] \[set idx]" $result
        if {[set enc2 [endianUtf $enc]] ne ""} {
            # If utf{16,32}-{le,be}, also do utf{16,32}
            testconvert $id.$enc2.default "list \[encoding $converter -failindex idx $enc2 $data] \[set idx]" $result
        }
    }
}

test cmdAH-4.1.1 {encoding} -returnCodes error -body {
    encoding
} -result {wrong # args: should be "encoding subcommand ?arg ...?"}
test cmdAH-4.1.2 {Tcl_EncodingObjCmd} -returnCodes error -body {
    encoding foo
} -result {unknown or ambiguous subcommand "foo": must be convertfrom, convertto, dirs, names, profiles, or system}

#
# encoding system 4.2.*
badnumargs cmdAH-4.2.1 {encoding system} {ascii ascii}
test cmdAH-4.2.2 {Tcl_EncodingObjCmd} -setup {
    set system [encoding system]
} -body {
    encoding system iso8859-1
    encoding system
} -cleanup {
    encoding system $system
} -result iso8859-1

#
# encoding convertfrom 4.3.*

# Odd number of args is always invalid since last two args
# are ENCODING DATA and all options take a value
badnumargs cmdAH-4.3.1 {encoding convertfrom} {}
badnumargs cmdAH-4.3.2 {encoding convertfrom} {-failindex VAR ABC}
badnumargs cmdAH-4.3.3 {encoding convertfrom} {-profile VAR ABC}
badnumargs cmdAH-4.3.4 {encoding convertfrom} {-failindex VAR -profile strict ABC}
badnumargs cmdAH-4.3.5 {encoding convertfrom} {-profile strict -failindex VAR ABC}

# Test that last two args always treated as ENCODING DATA
unknownencodingtest cmdAH-4.3.6 {convertfrom -failindex ABC}
unknownencodingtest cmdAH-4.3.7 {convertfrom -profile ABC}
unknownencodingtest cmdAH-4.3.8 {convertfrom nosuchencoding ABC}
unknownencodingtest cmdAH-4.3.9 {convertfrom -failindex VAR -profile ABC}
unknownencodingtest cmdAH-4.3.10 {convertfrom -profile strict -failindex ABC}
testconvert cmdAH-4.3.11 {
    encoding convertfrom jis0208 \x38\x43
} \u4e4e -setup {
    set system [encoding system]
    encoding system iso8859-1
} -cleanup {
    encoding system $system
}

# Verify single arg defaults to system encoding
testconvert cmdAH-4.3.12 {
    encoding convertfrom \x38\x43
} \u4e4e -setup {
    set system [encoding system]
    encoding system jis0208
} -cleanup {
    encoding system $system
}

# convertfrom ?-profile? : valid byte sequences
foreach {enc str hex} $encValidStrings {
    set bytes [binary decode hex $hex]
    set prefix A
    set suffix B
    set prefix_bytes [encoding convertto $enc A]
    set suffix_bytes [encoding convertto $enc B]
    foreach profile $encProfiles {
        testfailindex cmdAH-4.3.13.$hex.solo convertfrom $enc $bytes [list $str -1] $profile
        testfailindex cmdAH-4.3.13.$hex.lead convertfrom $enc $bytes$suffix_bytes [list $str$suffix -1] $profile
        testfailindex cmdAH-4.3.13.$hex.tail convertfrom $enc $prefix_bytes$bytes [list $prefix$str -1] $profile
        testfailindex cmdAH-4.3.13.$hex.middle convertfrom $enc $prefix_bytes$bytes$suffix_bytes [list $prefix$str$suffix -1] $profile
    }
}

# convertfrom ?-profile? : invalid byte sequences
foreach {enc hex profile str failidx ctrl comment} $encInvalidBytes {
    set bytes [binary format H* $hex]
    set prefix A
    set suffix B
    set prefix_bytes [encoding convertto $enc $prefix]
    set suffix_bytes [encoding convertto $enc $suffix]
    set prefixLen [string length $prefix_bytes]
    set result [list $str]
    # TODO - if the bad byte is unprintable, tcltest errors out when printing a mismatch
    # so glob it out in error message pattern for now.
    set errorWithoutPrefix [list "unexpected byte sequence starting at index $failidx: *" -returnCodes error -match glob]
    set errorWithPrefix [list "unexpected byte sequence starting at index [expr {$failidx+$prefixLen}]: *" -returnCodes error -match glob]
    if {$ctrl eq {} || "solo" in $ctrl} {
        if {$failidx == -1} {
            set result [list $str]
        } else {
            set result $errorWithoutPrefix
        }
        testprofile cmdAH-4.3.13.$hex.solo convertfrom $enc $profile $bytes {*}$result
    }
    if {$ctrl eq {} || "lead" in $ctrl} {
        if {$failidx == -1} {
            set result [list $str$suffix]
        } else {
            set result $errorWithoutPrefix
        }
        testprofile cmdAH-4.3.13.$hex.lead convertfrom $enc $profile $bytes$suffix_bytes {*}$result
    }
    if {$ctrl eq {} || "tail" in $ctrl} {
        if {$failidx == -1} {
            set result [list $prefix$str]
        } else {
            set result $errorWithPrefix
        }
        testprofile cmdAH-4.3.13.$hex.tail convertfrom $enc $profile $prefix_bytes$bytes {*}$result
    }
    if {$ctrl eq {} || "middle" in $ctrl} {
        if {$failidx == -1} {
            set result [list $prefix$str$suffix]
        } else {
            set result $errorWithPrefix
        }
        testprofile cmdAH-4.3.13.$hex.middle convertfrom $enc $profile $prefix_bytes$bytes$suffix_bytes {*}$result
    }
}

# convertfrom -failindex ?-profile? - valid data
foreach {enc str hex} $encValidStrings {
    set bytes [binary decode hex $hex]
    set prefix A
    set suffix B
    set prefix_bytes [encoding convertto $enc A]
    set suffix_bytes [encoding convertto $enc B]
    foreach profile $encProfiles {
        testfailindex cmdAH-4.3.14.$hex.solo convertfrom $enc $bytes [list $str -1] $profile
        testfailindex cmdAH-4.3.14.$hex.lead convertfrom $enc $bytes$suffix_bytes [list $str$suffix -1] $profile
        testfailindex cmdAH-4.3.14.$hex.tail convertfrom $enc $prefix_bytes$bytes [list $prefix$str -1] $profile
        testfailindex cmdAH-4.3.14.$hex.middle convertfrom $enc $prefix_bytes$bytes$suffix_bytes [list $prefix$str$suffix -1] $profile
    }
}

# convertfrom -failindex ?-profile? - invalid data
foreach {enc hex profile str failidx ctrl comment} $encInvalidBytes {
    # There are multiple test cases based on location of invalid bytes
    set bytes [binary decode hex $hex]
    set prefix A
    set suffix B
    set prefixLen [string length [encoding convertto $enc $prefix]]
    if {$ctrl eq {} || "solo" in $ctrl} {
        testfailindex cmdAH-4.3.14.$hex.solo convertfrom $enc $bytes [list $str $failidx] $profile
    }
    if {$ctrl eq {} || "lead" in $ctrl} {
        if {$failidx == -1} {
            # If success expected
            set result $str$suffix
        } else {
            # Failure expected
            set result ""
        }
        testfailindex cmdAH-4.3.14.$hex.lead convertfrom $enc $bytes$suffix [list $result $failidx] $profile
    }
    if {$ctrl eq {} || "tail" in $ctrl} {
        set expected_failidx $failidx
        if {$failidx == -1} {
            # If success expected
            set result $prefix$str
        } else {
            # Failure expected
            set result $prefix
            incr expected_failidx $prefixLen
        }
        testfailindex cmdAH-4.3.14.$hex.tail convertfrom $enc $prefix$bytes [list $result $expected_failidx] $profile
    }
    if {$ctrl eq {} || "middle" in $ctrl} {
        set expected_failidx $failidx
        if {$failidx == -1} {
            # If success expected
            set result $prefix$str$suffix
        } else {
            # Failure expected
            set result $prefix
            incr expected_failidx $prefixLen
        }
        testfailindex cmdAH-4.3.14.$hex.middle convertfrom $enc $prefix$bytes$suffix [list $result $expected_failidx] $profile
    }
}

#
# encoding convertto 4.4.*

badnumargs cmdAH-4.4.1 {encoding convertto} {}
badnumargs cmdAH-4.4.2 {encoding convertto} {-failindex VAR ABC}
badnumargs cmdAH-4.4.3 {encoding convertto} {-profile VAR ABC}
badnumargs cmdAH-4.4.4 {encoding convertto} {-failindex VAR -profile strict ABC}
badnumargs cmdAH-4.4.5 {encoding convertto} {-profile strict -failindex VAR ABC}

# Test that last two args always treated as ENCODING DATA
unknownencodingtest cmdAH-4.4.6 {convertto -failindex ABC}
unknownencodingtest cmdAH-4.4.7 {convertto -profile ABC}
unknownencodingtest cmdAH-4.4.8 {convertto nosuchencoding ABC}
unknownencodingtest cmdAH-4.4.9 {convertto -failindex VAR -profile ABC}
unknownencodingtest cmdAH-4.4.10 {convertto -profile strict -failindex ABC}
testconvert cmdAH-4.4.11 {
    encoding convertto jis0208 \u4e4e
} \x38\x43 -setup {
    set system [encoding system]
    encoding system iso8859-1
} -cleanup {
    encoding system $system
}

# Verify single arg defaults to system encoding
testconvert cmdAH-4.4.12 {
    encoding convertto \u4e4e
} \x38\x43 -setup {
    set system [encoding system]
    encoding system jis0208
} -cleanup {
    encoding system $system
}

# convertto ?-profile? : valid byte sequences

foreach {enc str hex} $encValidStrings {
    set bytes [binary decode hex $hex]
    set printable [printable $str]
    set prefix A
    set suffix B
    set prefix_bytes [encoding convertto $enc A]
    set suffix_bytes [encoding convertto $enc B]
    foreach profile $encProfiles {
        testprofile cmdAH-4.4.13.$printable.solo convertto $enc $profile $str $bytes
        testprofile cmdAH-4.4.13.$printable.lead convertto $enc $profile $str$suffix $bytes$suffix_bytes
        testprofile cmdAH-4.4.13.$printable.tail convertto $enc $profile $prefix$str $prefix_bytes$bytes
        testprofile cmdAH-4.4.13.$printable.middle convertto $enc $profile $prefix$str$suffix $prefix_bytes$bytes$suffix_bytes
    }
}

# convertto ?-profile? : invalid byte sequences
foreach {enc str profile hex failidx ctrl comment} $encUnencodableStrings {
    set bytes [binary decode hex $hex]
    set printable [printable $str]
    set prefix A
    set suffix B
    set prefix_bytes [encoding convertto $enc $prefix]
    set suffix_bytes [encoding convertto $enc $suffix]
    set prefixLen [string length $prefix_bytes]
    set result [list $bytes]
    # TODO - if the bad byte is unprintable, tcltest errors out when printing a mismatch
    # so glob it out in error message pattern for now.
    set errorWithoutPrefix [list "unexpected character at index $failidx: *" -returnCodes error -match glob]
    set errorWithPrefix [list "unexpected character at index [expr {$failidx+$prefixLen}]: *" -returnCodes error -match glob]
    if {$ctrl eq {} || "solo" in $ctrl} {
        if {$failidx == -1} {
            set result [list $bytes]
        } else {
            set result $errorWithoutPrefix
        }
        testprofile cmdAH-4.4.13.$printable.solo convertto $enc $profile $str {*}$result
    }
    if {$ctrl eq {} || "lead" in $ctrl} {
        if {$failidx == -1} {
            set result [list $bytes$suffix_bytes]
        } else {
            set result $errorWithoutPrefix
        }
        testprofile cmdAH-4.4.13.$printable.lead convertto $enc $profile $str$suffix {*}$result
    }
    if {$ctrl eq {} || "tail" in $ctrl} {
        if {$failidx == -1} {
            set result [list $prefix_bytes$bytes]
        } else {
            set result $errorWithPrefix
        }
        testprofile cmdAH-4.4.13.$printable.tail convertto $enc $profile $prefix$str {*}$result
    }
    if {$ctrl eq {} || "middle" in $ctrl} {
        if {$failidx == -1} {
            set result [list $prefix_bytes$bytes$suffix_bytes]
        } else {
            set result $errorWithPrefix
        }
        testprofile cmdAH-4.4.13.$printable.middle convertto $enc $profile $prefix$str$suffix {*}$result
    }
}

# convertto -failindex ?-profile? - valid data
foreach {enc str hex} $encValidStrings {
    set bytes [binary decode hex $hex]
    set printable [printable $str]
    set prefix A
    set suffix B
    set prefix_bytes [encoding convertto $enc A]
    set suffix_bytes [encoding convertto $enc B]
    foreach profile $encProfiles {
        testfailindex cmdAH-4.4.14.$enc.$printable.solo convertto $enc $str [list $bytes -1] $profile
        testfailindex cmdAH-4.4.14.$enc.$printable.lead convertto $enc $str$suffix [list $bytes$suffix_bytes -1] $profile
        testfailindex cmdAH-4.4.14.$enc.$printable.tail convertto $enc $prefix$str [list $prefix_bytes$bytes -1] $profile
        testfailindex cmdAH-4.4.14.$enc.$printable.middle convertto $enc $prefix$str$suffix [list $prefix_bytes$bytes$suffix_bytes -1] $profile
    }
}

# convertto -failindex ?-profile? - invalid data
foreach {enc str profile hex failidx ctrl comment} $encUnencodableStrings {
    set bytes [binary decode hex $hex]
    set printable [printable $str]
    set prefix A
    set suffix B
    set prefixLen [string length [encoding convertto $enc $prefix]]
    if {$ctrl eq {} || "solo" in $ctrl} {
        testfailindex cmdAH-4.4.14.$printable.solo convertto $enc $str [list $bytes $failidx] $profile
    }
    if {$ctrl eq {} || "lead" in $ctrl} {
        if {$failidx == -1} {
            # If success expected
            set result $bytes$suffix
        } else {
            # Failure expected
            set result ""
        }
        testfailindex cmdAH-4.4.14.$printable.lead convertto $enc $str$suffix [list $result $failidx] $profile
    }
    if {$ctrl eq {} || "tail" in $ctrl} {
        set expected_failidx $failidx
        if {$failidx == -1} {
            # If success expected
            set result $prefix$bytes
        } else {
            # Failure expected
            set result $prefix
            incr expected_failidx $prefixLen
        }
        testfailindex cmdAH-4.4.14.$printable.tail convertto $enc $prefix$str [list $result $expected_failidx] $profile
    }
    if {$ctrl eq {} || "middle" in $ctrl} {
        set expected_failidx $failidx
        if {$failidx == -1} {
            # If success expected
            set result $prefix$bytes$suffix
        } else {
            # Failure expected
            set result $prefix
            incr expected_failidx $prefixLen
        }
        testfailindex cmdAH-4.4.14.$printable.middle convertto $enc $prefix$str$suffix [list $result $expected_failidx] $profile
    }
}

test cmdAH-4.4.xx {convertto -profile strict} -constraints {testbytestring knownBug} -body {
    # TODO - what does testbytestring even test? Invalid UTF8 in the Tcl_Obj bytes field
    encoding convertto -profile strict utf-8 A[testbytestring \x80]B
} -returnCodes error -result {unexpected byte sequence starting at index 1: '\x80'}

#
# encoding names 4.5.*
badnumargs cmdAH-4.5.1 {encoding names} {foo}
test cmdAH-4.5.2 {encoding names should include at least utf-8 and iso8859-1 and at least one more} -body {
    set names [encoding names]
    list [expr {"utf-8" in $names}] [expr {"iso8859-1" in $names}] [expr {[llength $names] > 2}]
} -result {1 1 1}

#
# encoding profiles 4.6.*
badnumargs cmdAH-4.6.1 {encoding profiles} {foo}
test cmdAH-4.6.2 {encoding profiles} -body {
    lsort [encoding profiles]
} -result {replace strict tcl8}

#
# file command

test cmdAH-5.1 {Tcl_FileObjCmd} -returnCodes error -body {
    file
} -result {wrong # args: should be "file subcommand ?arg ...?"}
test cmdAH-5.2 {Tcl_FileObjCmd} -returnCodes error -body {
    file x
} -result {unknown or ambiguous subcommand "x": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, home, isdirectory, isfile, join, link, lstat, mkdir, mtime, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, tempdir, tempfile, tildeexpand, type, volumes, or writable}
test cmdAH-5.3 {Tcl_FileObjCmd} -returnCodes error -body {
    file exists
} -result {wrong # args: should be "file exists name"}
test cmdAH-5.4 {Tcl_FileObjCmd} {
    file exists ""
} 0

# volume
test cmdAH-6.1 {Tcl_FileObjCmd: volumes} -returnCodes error -body {
    file volumes x
} -result {wrong # args: should be "file volumes"}
test cmdAH-6.2 {Tcl_FileObjCmd: volumes} -body {
    lindex [file volumes] 0
} -match glob -result ?*
test cmdAH-6.3 {Tcl_FileObjCmd: volumes} -constraints unix -body {
    set volumeList [file volumes]
    glob -nocomplain [lindex $volumeList 0]*
} -match glob -result *
test cmdAH-6.4 {Tcl_FileObjCmd: volumes} -constraints win -body {
    set volumeList [string tolower [file volumes]]
    set element [lsearch -exact $volumeList "c:/"]
    list [expr {$element>=0}] [glob -nocomplain [lindex $volumeList $element]*]
} -match glob -result {1 *}

# attributes
test cmdAH-7.1 {Tcl_FileObjCmd - file attrs} -setup {
    set foofile [makeFile abcde foo.file]
    catch {file delete -force $foofile}
} -body {
    close [open $foofile w]
    file attributes $foofile
} -cleanup {
    # We used [makeFile] so we undo with [removeFile]
    removeFile $foofile
} -match glob -result *

# dirname
test cmdAH-8.1 {Tcl_FileObjCmd: dirname} -returnCodes error -body {
    file dirname a b
} -result {wrong # args: should be "file dirname name"}
test cmdAH-8.2 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname /a/b
} /a
test cmdAH-8.3 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname {}
} .
test cmdAH-8.5 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform win
    file dirname {}
} .
test cmdAH-8.6 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname .def
} .
test cmdAH-8.8 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform win
    file dirname a
} .
test cmdAH-8.9 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname a/b/c.d
} a/b
test cmdAH-8.10 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname a/b.c/d
} a/b.c
test cmdAH-8.11 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname /.
} /
test cmdAH-8.12 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname /
} /
test cmdAH-8.13 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname /foo
} /
test cmdAH-8.14 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname //foo
} //foo
test cmdAH-8.15 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname //foo/bar
} //foo
test cmdAH-8.16 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname {//foo\/bar/baz}
} {//foo\/bar}
test cmdAH-8.17 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname {//foo\/bar/baz/blat}
} {//foo\/bar/baz}
test cmdAH-8.18 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname /foo//
} /
test cmdAH-8.19 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname ./a
} .
test cmdAH-8.20 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname a/.a
} a
test cmdAH-8.21 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform windows
    file dirname c:foo
} c:
test cmdAH-8.22 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform windows
    file dirname c:
} c:
test cmdAH-8.23 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform windows
    file dirname c:/
} c:/
test cmdAH-8.24 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform windows
    file dirname {c:\foo}
} c:/
test cmdAH-8.25 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform windows
    file dirname {//foo/bar/baz}
} //foo/bar
test cmdAH-8.26 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform windows
    file dirname {//foo/bar}
} //foo/bar
test cmdAH-8.38 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname ~/foo
} ~
test cmdAH-8.39 {Tcl_FileObjCmd: dirname} testsetplatform {
    testsetplatform unix
    file dirname ~bar/foo
} ~bar
test cmdAH-8.43 {Tcl_FileObjCmd: dirname} -setup {
    global env
    set temp $env(HOME)
} -constraints testsetplatform -body {
    set env(HOME) "/homewontexist/test"
    testsetplatform unix
    file dirname ~
} -cleanup {
    set env(HOME) $temp
} -result /homewontexist
test cmdAH-8.44 {Tcl_FileObjCmd: dirname} -setup {
    global env
    set temp $env(HOME)
} -constraints testsetplatform -body {
    set env(HOME) "~"
    testsetplatform unix
    file dirname ~
} -cleanup {
    set env(HOME) $temp
} -result ~
test cmdAH-8.45 {Tcl_FileObjCmd: dirname} -setup {
    set temp $::env(HOME)
} -constraints {win testsetplatform} -match regexp -body {
    set ::env(HOME) "/homewontexist/test"
    testsetplatform windows
    file dirname ~
} -cleanup {
    set ::env(HOME) $temp
} -result {([a-zA-Z]:?)/homewontexist}
test cmdAH-8.46 {Tcl_FileObjCmd: dirname} {
    set f [file normalize [info nameof]]
    file exists $f
    set res1 [file dirname [file join $f foo/bar]]
    set res2 [file dirname "${f}/foo/bar"]
    if {$res1 eq $res2} {
	return "ok"
    }
    return "file dirname problem, $res1, $res2 not equal"
} {ok}

# tail
test cmdAH-9.1 {Tcl_FileObjCmd: tail} -returnCodes error -body {
    file tail a b
} -result {wrong # args: should be "file tail name"}
test cmdAH-9.2 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform unix
    file tail /a/b
} b
test cmdAH-9.3 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform unix
    file tail {}
} {}
test cmdAH-9.5 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform win
    file tail {}
} {}
test cmdAH-9.6 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform unix
    file tail .def
} .def
test cmdAH-9.8 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform win
    file tail a
} a
test cmdAH-9.9 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform unix
    file ta a/b/c.d
} c.d
test cmdAH-9.10 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform unix
    file tail a/b.c/d
} d
test cmdAH-9.11 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform unix
    file tail /.
} .
test cmdAH-9.12 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform unix
    file tail /
} {}
test cmdAH-9.13 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform unix
    file tail /foo
} foo
test cmdAH-9.14 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform unix
    file tail //foo
} {}
test cmdAH-9.15 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform unix
    file tail //foo/bar
} bar
test cmdAH-9.16 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform unix
    file tail {//foo\/bar/baz}
} baz
test cmdAH-9.17 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform unix
    file tail {//foo\/bar/baz/blat}
} blat
test cmdAH-9.18 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform unix
    file tail /foo//
} foo
test cmdAH-9.19 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform unix
    file tail ./a
} a
test cmdAH-9.20 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform unix
    file tail a/.a
} .a
test cmdAH-9.21 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform windows
    file tail c:foo
} foo
test cmdAH-9.22 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform windows
    file tail c:
} {}
test cmdAH-9.23 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform windows
    file tail c:/
} {}
test cmdAH-9.24 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform windows
    file tail {c:\foo}
} foo
test cmdAH-9.25 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform windows
    file tail {//foo/bar/baz}
} baz
test cmdAH-9.26 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform windows
    file tail {//foo/bar}
} {}
test cmdAH-9.42 {Tcl_FileObjCmd: tail} -constraints testsetplatform -setup {
    global env
    set temp $env(HOME)
} -body {
    set env(HOME) "/home/test"
    testsetplatform unix
    file tail ~
} -cleanup {
    set env(HOME) $temp
} -result test
test cmdAH-9.43 {Tcl_FileObjCmd: tail} -constraints testsetplatform -setup {
    global env
    set temp $env(HOME)
} -body {
    set env(HOME) "~"
    testsetplatform unix
    file tail ~
} -cleanup {
    set env(HOME) $temp
} -result {}
test cmdAH-9.44 {Tcl_FileObjCmd: tail} -constraints testsetplatform -setup {
    global env
    set temp $env(HOME)
} -body {
    set env(HOME) "/home/test"
    testsetplatform windows
    file tail ~
} -cleanup {
    set env(HOME) $temp
} -result test
test cmdAH-9.46 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform unix
    file tail {f.oo\bar/baz.bat}
} baz.bat
test cmdAH-9.47 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform windows
    file tail c:foo
} foo
test cmdAH-9.48 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform windows
    file tail c:
} {}
test cmdAH-9.49 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform windows
    file tail c:/foo
} foo
test cmdAH-9.50 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform windows
    file tail {c:/foo\bar}
} bar
test cmdAH-9.51 {Tcl_FileObjCmd: tail} testsetplatform {
    testsetplatform windows
    file tail {foo\bar}
} bar
test cmdAH-9.52 {Tcl_FileObjCmd: tail / normalize, bug 7a9dc52b29} {
    list \
	[file tail {~/~foo}] \
	[file tail {~/test/~foo}] \
	[file tail [file normalize {~/~foo}]] \
	[file tail [file normalize {~/test/~foo}]]
} [lrepeat 4 ./~foo]

# rootname
test cmdAH-10.1 {Tcl_FileObjCmd: rootname} -returnCodes error -body {
    file rootname a b
} -result {wrong # args: should be "file rootname name"}
test cmdAH-10.2 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform unix
    file rootname {}
} {}
test cmdAH-10.3 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform unix
    file ro foo
} foo
test cmdAH-10.4 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform unix
    file rootname foo.
} foo
test cmdAH-10.5 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform unix
    file rootname .foo
} {}
test cmdAH-10.6 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform unix
    file rootname abc.def
} abc
test cmdAH-10.7 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform unix
    file rootname abc.def.ghi
} abc.def
test cmdAH-10.8 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform unix
    file rootname a/b/c.d
} a/b/c
test cmdAH-10.9 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform unix
    file rootname a/b.c/d
} a/b.c/d
test cmdAH-10.10 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform unix
    file rootname a/b.c/
} a/b.c/
test cmdAH-10.23 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform windows
    file rootname {}
} {}
test cmdAH-10.24 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform windows
    file ro foo
} foo
test cmdAH-10.25 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform windows
    file rootname foo.
} foo
test cmdAH-10.26 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform windows
    file rootname .foo
} {}
test cmdAH-10.27 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform windows
    file rootname abc.def
} abc
test cmdAH-10.28 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform windows
    file rootname abc.def.ghi
} abc.def
test cmdAH-10.29 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform windows
    file rootname a/b/c.d
} a/b/c
test cmdAH-10.30 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform windows
    file rootname a/b.c/d
} a/b.c/d
test cmdAH-10.31 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform windows
    file rootname a\\b.c\\
} a\\b.c\\
test cmdAH-10.32 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform windows
    file rootname a\\b\\c.d
} a\\b\\c
test cmdAH-10.33 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform windows
    file rootname a\\b.c\\d
} a\\b.c\\d
test cmdAH-10.34 {Tcl_FileObjCmd: rootname} testsetplatform {
    testsetplatform windows
    file rootname a\\b.c\\
} a\\b.c\\
set num 35
foreach outer { {} a .a a. a.a } {
    foreach inner { {} a .a a. a.a } {
	set thing [format %s/%s $outer $inner]
	;test cmdAH-10.$num {Tcl_FileObjCmd: rootname and extension options} testsetplatform "
	    testsetplatform unix
	    [list format %s%s [file rootname $thing] [file ext $thing]]
	" $thing
	incr num
    }
}

# extension
test cmdAH-11.1 {Tcl_FileObjCmd: extension} -returnCodes error -body {
    file extension a b
} -result {wrong # args: should be "file extension name"}
test cmdAH-11.2 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform unix
    file extension {}
} {}
test cmdAH-11.3 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform unix
    file ext foo
} {}
test cmdAH-11.4 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform unix
    file extension foo.
} .
test cmdAH-11.5 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform unix
    file extension .foo
} .foo
test cmdAH-11.6 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform unix
    file extension abc.def
} .def
test cmdAH-11.7 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform unix
    file extension abc.def.ghi
} .ghi
test cmdAH-11.8 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform unix
    file extension a/b/c.d
} .d
test cmdAH-11.9 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform unix
    file extension a/b.c/d
} {}
test cmdAH-11.10 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform unix
    file extension a/b.c/
} {}
test cmdAH-11.23 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform windows
    file extension {}
} {}
test cmdAH-11.24 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform windows
    file ext foo
} {}
test cmdAH-11.25 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform windows
    file extension foo.
} .
test cmdAH-11.26 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform windows
    file extension .foo
} .foo
test cmdAH-11.27 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform windows
    file extension abc.def
} .def
test cmdAH-11.28 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform windows
    file extension abc.def.ghi
} .ghi
test cmdAH-11.29 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform windows
    file extension a/b/c.d
} .d
test cmdAH-11.30 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform windows
    file extension a/b.c/d
} {}
test cmdAH-11.31 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform windows
    file extension a\\b.c\\
} {}
test cmdAH-11.32 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform windows
    file extension a\\b\\c.d
} .d
test cmdAH-11.33 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform windows
    file extension a\\b.c\\d
} {}
test cmdAH-11.34 {Tcl_FileObjCmd: extension} testsetplatform {
    testsetplatform windows
    file extension a\\b.c\\
} {}
foreach {test onPlatform value result} {
    cmdAH-11.35 unix    a..b   .b
    cmdAH-11.36 windows a..b   .b
    cmdAH-11.37 unix    a...b  .b
    cmdAH-11.38 windows a...b  .b
    cmdAH-11.39 unix    a.c..b .b
    cmdAH-11.40 windows a.c..b .b
    cmdAH-11.41 unix    ..b    .b
    cmdAH-11.42 windows ..b    .b
} {
    test $test {Tcl_FileObjCmd: extension} testsetplatform "
	testsetplatform $onPlatform
	file extension $value
    " $result
}

# pathtype
test cmdAH-12.1 {Tcl_FileObjCmd: pathtype} -returnCodes error -body {
    file pathtype a b
} -result {wrong # args: should be "file pathtype name"}
test cmdAH-12.2 {Tcl_FileObjCmd: pathtype} testsetplatform {
    testsetplatform unix
    file pathtype /a
} absolute
test cmdAH-12.3 {Tcl_FileObjCmd: pathtype} testsetplatform {
    testsetplatform unix
    file p a
} relative
test cmdAH-12.4 {Tcl_FileObjCmd: pathtype} testsetplatform {
    testsetplatform windows
    file pathtype c:a
} volumerelative

# split
test cmdAH-13.1 {Tcl_FileObjCmd: split} -returnCodes error -body {
    file split a b
} -result {wrong # args: should be "file split name"}
test cmdAH-13.2 {Tcl_FileObjCmd: split} testsetplatform {
    testsetplatform unix
    file split a
} a
test cmdAH-13.3 {Tcl_FileObjCmd: split} testsetplatform {
    testsetplatform unix
    file split a/b
} {a b}

# join
test cmdAH-14.1 {Tcl_FileObjCmd: join} testsetplatform {
    testsetplatform unix
    file join a
} a
test cmdAH-14.2 {Tcl_FileObjCmd: join} testsetplatform {
    testsetplatform unix
    file join a b
} a/b
test cmdAH-14.3 {Tcl_FileObjCmd: join} testsetplatform {
    testsetplatform unix
    file join a b c d
} a/b/c/d

# error handling of Tcl_TranslateFileName
test cmdAH-15.1 {Tcl_FileObjCmd} -constraints testsetplatform -body {
    testsetplatform unix
    file atime ~_bad_user
} -returnCodes error -result {user "_bad_user" doesn't exist}

catch {testsetplatform $platform}

# readable
set gorpfile [makeFile abcde gorp.file]
set dirfile [makeDirectory dir.file]
test cmdAH-16.1 {Tcl_FileObjCmd: readable} {
    -returnCodes error
    -body   {file readable a b}
    -result {wrong # args: should be "file readable name"}
}
test cmdAH-16.2 {Tcl_FileObjCmd: readable} {
    -constraints testchmod
    -setup  	 {testchmod 0o444 $gorpfile}
    -body   	 {file readable $gorpfile}
    -result 	 1
}
test cmdAH-16.3 {Tcl_FileObjCmd: readable} {
    -constraints {unix notRoot testchmod}
    -setup  	 {testchmod 0o333 $gorpfile}
    -body   	 {file readable $gorpfile}
    -result 	 0
}

# writable
test cmdAH-17.1 {Tcl_FileObjCmd: writable} {
    -returnCodes error
    -body   {file writable a b}
    -result {wrong # args: should be "file writable name"}
}
test cmdAH-17.2 {Tcl_FileObjCmd: writable} {
    -constraints {notRoot testchmod}
    -setup  	 {testchmod 0o555 $gorpfile}
    -body   	 {file writable $gorpfile}
    -result 	 0
}
test cmdAH-17.3 {Tcl_FileObjCmd: writable} {
    -constraints testchmod
    -setup  	 {testchmod 0o222 $gorpfile}
    -body   	 {file writable $gorpfile}
    -result 	 1
}

# executable
removeFile $gorpfile
removeDirectory $dirfile
set dirfile [makeDirectory dir.file]
set gorpfile [makeFile abcde gorp.file]
test cmdAH-18.1 {Tcl_FileObjCmd: executable} -returnCodes error -body {
    file executable a b
} -result {wrong # args: should be "file executable name"}
test cmdAH-18.2 {Tcl_FileObjCmd: executable} {notRoot} {
    file executable $gorpfile
} 0
test cmdAH-18.3 {Tcl_FileObjCmd: executable} {unix testchmod} {
    # Only on unix will setting the execute bit on a regular file cause that
    # file to be executable.
    testchmod 0o775 $gorpfile
    file exe $gorpfile
} 1
test cmdAH-18.5 {Tcl_FileObjCmd: executable} -constraints {win} -body {
    # On windows, must be a .exe, .com, etc.
    set x {}
    set gorpexes {}
    foreach ext {exe com cmd bat} {
        lappend x [file exe nosuchfile.$ext]
        set gorpexe [makeFile foo gorp.$ext]
        lappend gorpexes $gorpexe
        lappend x [file exe $gorpexe] [file exe [string toupper $gorpexe]]
    }
    set x
} -cleanup {
    foreach gorpexe $gorpexes {
        removeFile $gorpexe
    }
} -result {0 1 1 0 1 1 0 1 1 0 1 1}
test cmdAH-18.6 {Tcl_FileObjCmd: executable} {} {
    # Directories are always executable.
    file exe $dirfile
} 1

removeDirectory $dirfile
removeFile $gorpfile
set linkfile [file join [temporaryDirectory] link.file]
file delete $linkfile

# exists
test cmdAH-19.1 {Tcl_FileObjCmd: exists} -returnCodes error -body {
    file exists a b
} -result {wrong # args: should be "file exists name"}
test cmdAH-19.2 {Tcl_FileObjCmd: exists} {file exists $gorpfile} 0
test cmdAH-19.3 {Tcl_FileObjCmd: exists} {
    file exists [file join [temporaryDirectory] dir.file gorp.file]
} 0
catch {
    set gorpfile [makeFile abcde gorp.file]
    set dirfile [makeDirectory dir.file]
    set subgorp [makeFile 12345 [file join $dirfile gorp.file]]
}
test cmdAH-19.4 {Tcl_FileObjCmd: exists} {
    file exists $gorpfile
} 1
test cmdAH-19.5 {Tcl_FileObjCmd: exists} {
    file exists $subgorp
} 1
# nativename
test cmdAH-19.6 {Tcl_FileObjCmd: nativename} -body {
    testsetplatform unix
    file nativename a/b
} -constraints testsetplatform -cleanup {
    testsetplatform $platform
} -result a/b
test cmdAH-19.7 {Tcl_FileObjCmd: nativename} -body {
    testsetplatform windows
    file nativename a/b
} -constraints testsetplatform -cleanup {
    testsetplatform $platform
} -result {a\b}
test cmdAH-19.9 {Tcl_FileObjCmd: ~ : exists} {
    file exists ~nOsUcHuSeR
} 0
test cmdAH-19.10 {Tcl_FileObjCmd: ~ : nativename} -body {
    # should probably be a non-error in fact...
    file nativename ~nOsUcHuSeR
} -returnCodes error -match glob -result *
# The test below has to be done in /tmp rather than the current directory in
# order to guarantee (?) a local file system: some NFS file systems won't do
# the stuff below correctly.
test cmdAH-19.11 {Tcl_FileObjCmd: exists} -constraints {unix notRoot} -setup {
    file delete -force /tmp/tcl.foo.dir/file
    file delete -force /tmp/tcl.foo.dir
} -body {
    makeDirectory /tmp/tcl.foo.dir
    makeFile 12345 /tmp/tcl.foo.dir/file
    file attributes /tmp/tcl.foo.dir -permissions 0
    file exists /tmp/tcl.foo.dir/file
} -cleanup {
    file attributes /tmp/tcl.foo.dir -permissions 0o775
    removeFile /tmp/tcl.foo.dir/file
    removeDirectory /tmp/tcl.foo.dir
} -result 0
test cmdAH-19.12 {Bug 3608360: [file exists] mustn't do globbing} -setup {
    set newdirfile [makeDirectory newdir.file]
    set cwd [pwd]
    cd $newdirfile
    # Content of file is totally unimportant; name is *not*
    set innocentBystander [makeFile "abc" [file join $newdirfile foo.bar]]
} -body {
    list [file exists foo.bar] [file exists *.bar]
} -cleanup {
    cd $cwd
    removeFile $innocentBystander
    removeDirectory $newdirfile
} -result {1 0}

# Stat related commands

catch {testsetplatform $platform}
removeFile $gorpfile
set gorpfile [makeFile "Test string" gorp.file]
catch {file attributes $gorpfile -permissions 0o765}

# avoid problems with non-local filesystems
if {[testConstraint unix] && [file exists /tmp]} {
    set file [makeFile "data" touch.me /tmp]
} else {
    set file [makeFile "data" touch.me]
}

# atime
test cmdAH-20.1 {Tcl_FileObjCmd: atime} -returnCodes error -body {
    file atime a b c
} -result {wrong # args: should be "file atime name ?time?"}
test cmdAH-20.2 {Tcl_FileObjCmd: atime} -setup {
    unset -nocomplain stat
} -body {
    file stat $gorpfile stat
    list [expr {[file mtime $gorpfile] == $stat(mtime)}] \
	    [expr {[file atime $gorpfile] == $stat(atime)}]
} -result {1 1}
test cmdAH-20.3 {Tcl_FileObjCmd: atime} {
    list [catch {file atime _bogus_} msg] [string tolower $msg] $errorCode
} {1 {could not read "_bogus_": no such file or directory} {POSIX ENOENT {no such file or directory}}}
test cmdAH-20.4 {Tcl_FileObjCmd: atime} -returnCodes error -body {
    file atime $file notint
} -result {expected integer but got "notint"}
test cmdAH-20.5 {Tcl_FileObjCmd: atime touch} {unix} {
    set atime [file atime $file]
    after 1100; # pause a sec to notice change in atime
    set newatime [clock seconds]
    set modatime [file atime $file $newatime]
    expr {$newatime == $modatime ? 1 : "$newatime != $modatime"}
} 1
test cmdAH-20.6 {Tcl_FileObjCmd: atime touch} -setup {
    set old [pwd]
    cd $::tcltest::temporaryDirectory
    set volumetype [testvolumetype]
    cd $old
} -constraints {win testvolumetype} -body {
    if {"NTFS" ne $volumetype} {
	# Windows FAT doesn't understand atime, but NTFS does. May also fail
	# for Windows on NFS mounted disks.
	return 1
    }
    cd $old
    set atime [file atime $file]
    after 1100; # pause a sec to notice change in atime
    set newatime [clock seconds]
    set modatime [file atime $file $newatime]
    expr {$newatime == $modatime ? 1 : "$newatime != $modatime"}
} -result 1
test cmdAH-20.7 {
    Tcl_FileObjCmd: atime (built-in Windows names)
} -constraints {win} -body {
    file atime con
} -result "could not get access time for file \"con\"" -returnCodes error
test cmdAH-20.7.1 {
    Tcl_FileObjCmd: atime (built-in Windows names with dir path and extension)
} -constraints {win} -body {
    file atime [file join [temporaryDirectory] CON.txt]
} -match regexp -result {could not (?:get access time|read)} -returnCodes error

if {[testConstraint unix] && [file exists /tmp]} {
    removeFile touch.me /tmp
} else {
    removeFile touch.me
}

# isdirectory
test cmdAH-21.1 {Tcl_FileObjCmd: isdirectory} -returnCodes error -body {
    file isdirectory a b
} -result {wrong # args: should be "file isdirectory name"}
test cmdAH-21.2 {Tcl_FileObjCmd: isdirectory} {file isdirectory $gorpfile} 0
test cmdAH-21.3 {Tcl_FileObjCmd: isdirectory} {file isdirectory $dirfile} 1

# isfile
test cmdAH-22.1 {Tcl_FileObjCmd: isfile} -returnCodes error -body {
    file isfile a b
} -result {wrong # args: should be "file isfile name"}
test cmdAH-22.2 {Tcl_FileObjCmd: isfile} {file isfile $gorpfile} 1
test cmdAH-22.3 {Tcl_FileObjCmd: isfile} {file isfile $dirfile} 0

# lstat and readlink: don't run these tests everywhere, since not all sites
# will have symbolic links
catch {file link -symbolic $linkfile $gorpfile}
test cmdAH-23.1 {Tcl_FileObjCmd: lstat} -returnCodes error -body {
    file lstat a
} -result {could not read "a": no such file or directory}
test cmdAH-23.2 {Tcl_FileObjCmd: lstat} -returnCodes error -body {
    file lstat a b c
} -result {wrong # args: should be "file lstat name ?varName?"}
test cmdAH-23.3 {Tcl_FileObjCmd: lstat} -setup {
    unset -nocomplain stat
} -constraints {unix nonPortable} -body {
    file lstat $linkfile stat
    lsort [array names stat]
} -result {atime ctime dev gid ino mode mtime nlink size type uid}
test cmdAH-23.4 {Tcl_FileObjCmd: lstat} -setup {
    unset -nocomplain stat
} -constraints {unix nonPortable} -body {
    file lstat $linkfile stat
    list $stat(nlink) [expr {$stat(mode) & 0o777}] $stat(type)
} -result {1 511 link}
test cmdAH-23.5 {Tcl_FileObjCmd: lstat errors} {nonPortable} {
    list [catch {file lstat _bogus_ stat} msg] [string tolower $msg] \
	$errorCode
} {1 {could not read "_bogus_": no such file or directory} {POSIX ENOENT {no such file or directory}}}
test cmdAH-23.6 {Tcl_FileObjCmd: lstat errors} -setup {
    unset -nocomplain x
} -body {
    set x 44
    list [catch {file lstat $gorpfile x} msg] $msg $errorCode
} -result {1 {can't set "x(dev)": variable isn't array} {TCL LOOKUP VARNAME x}}
unset -nocomplain stat
# mkdir
set dirA [file join [temporaryDirectory] a]
set dirB [file join [temporaryDirectory] a]
test cmdAH-23.7 {Tcl_FileObjCmd: mkdir} -setup {
    catch {file delete -force $dirA}
} -body {
    file mkdir $dirA
    file isdirectory $dirA
} -cleanup {
    file delete $dirA
} -result {1}
test cmdAH-23.8 {Tcl_FileObjCmd: mkdir} -setup {
    catch {file delete -force $dirA}
} -body {
    file mkdir $dirA/b
    file isdirectory $dirA/b
} -cleanup {
    file delete -force $dirA
} -result {1}
test cmdAH-23.9 {Tcl_FileObjCmd: mkdir} -setup {
    catch {file delete -force $dirA}
} -body {
    file mkdir $dirA/b/c
    file isdirectory $dirA/b/c
} -cleanup {
    file delete -force $dirA
} -result {1}
test cmdAH-23.10 {Tcl_FileObjCmd: mkdir} -setup {
    catch {file delete -force $dirA}
    catch {file delete -force $dirB}
} -body {
    file mkdir $dirA/b $dirB/a/c
    list [file isdirectory $dirA/b] [file isdirectory $dirB/a/c]
} -cleanup {
    file delete -force $dirA
    file delete -force $dirB
} -result {1 1}
test cmdAH-23.11 {Tcl_FileObjCmd: mkdir} {
    # Allow zero arguments (TIP 323)
    file mkdir
} {}

set file [makeFile "data" touch.me]
# mtime
test cmdAH-24.1 {Tcl_FileObjCmd: mtime} -returnCodes error -body {
    file mtime a b c
} -result {wrong # args: should be "file mtime name ?time?"}
test cmdAH-24.2 {Tcl_FileObjCmd: mtime} -setup {
    # Check (allowing for clock-skew and OS interrupts as best we can) that
    # the change in mtime on a file being written is the time elapsed between
    # writes. Note that this can still fail on very busy systems if there are
    # long preemptions between the writes and the reading of the clock, but
    # there's not much you can do about that other than the completely
    # horrible "keep on trying to write until you managed to do it all in less
    # than a second." - DKF
    waitForEvenSecondForFAT
} -body {
    set f [open $gorpfile w]
    puts $f "More text"
    close $f
    set clockOld [clock seconds]
    set fileOld [file mtime $gorpfile]
    after 2000
    set f [open $gorpfile w]
    puts $f "More text"
    close $f
    set clockNew [clock seconds]
    set fileNew [file mtime $gorpfile]
    expr {
	(($fileNew > $fileOld) && ($clockNew > $clockOld) &&
	(abs(($fileNew-$fileOld) - ($clockNew-$clockOld)) <= 1)) ? "1" :
	"file:($fileOld=>$fileNew) clock:($clockOld=>$clockNew)"
    }
} -result {1}
test cmdAH-24.3 {Tcl_FileObjCmd: mtime} -setup {
    unset -nocomplain stat
} -body {
    file stat $gorpfile stat
    list [expr {[file mtime $gorpfile] == $stat(mtime)}] \
	    [expr {[file atime $gorpfile] == $stat(atime)}]
} -result {1 1}
test cmdAH-24.4 {Tcl_FileObjCmd: mtime} {
    list [catch {file mtime _bogus_} msg] [string tolower $msg] $errorCode
} {1 {could not read "_bogus_": no such file or directory} {POSIX ENOENT {no such file or directory}}}
test cmdAH-24.5 {Tcl_FileObjCmd: mtime} -setup {
    # Under Unix, use a file in /tmp to avoid clock skew due to NFS. On other
    # platforms, just use a file in the local directory.
    if {[testConstraint unix]} {
	set name /tmp/tcl.test.[pid]
    } else {
	set name [file join [temporaryDirectory] tf]
    }
} -body {
    # Make sure that a new file's time is correct. 10 seconds variance is
    # allowed used due to slow networks or clock skew on a network drive.
    file delete -force $name
    close [open $name w]
    expr {abs([clock seconds]-[file mtime $name])<10}
} -cleanup {
    file delete $name
} -result {1}
test cmdAH-24.7 {Tcl_FileObjCmd: mtime} -returnCodes error -body {
    file mtime $file notint
} -result {expected integer but got "notint"}
test cmdAH-24.8 {Tcl_FileObjCmd: mtime touch} unix {
    set mtime [file mtime $file]
    after 1100; # pause a sec to notice change in mtime
    set newmtime [clock seconds]
    set modmtime [file mtime $file $newmtime]
    expr {$newmtime == $modmtime ? 1 : "$newmtime != $modmtime"}
} 1
test cmdAH-24.9 {Tcl_FileObjCmd: mtime touch with non-ascii chars} -setup {
    set oldfile $file
} -constraints unix -body {
    # introduce some non-ascii characters.
    append file •
    file delete -force $file
    file rename $oldfile $file
    set mtime [file mtime $file]
    after 1100; # pause a sec to notice change in mtime
    set newmtime [clock seconds]
    set modmtime [file mtime $file $newmtime]
    expr {$newmtime == $modmtime ? 1 : "$newmtime != $modmtime"}
} -cleanup {
    file rename $file $oldfile
} -result 1
test cmdAH-24.10 {Tcl_FileObjCmd: mtime touch} -constraints win -setup {
    waitForEvenSecondForFAT
} -body {
    set mtime [file mtime $file]
    after 2100; # pause two secs to notice change in mtime on FAT fs'es
    set newmtime [clock seconds]
    set modmtime [file mtime $file $newmtime]
    expr {$newmtime == $modmtime ? 1 : "$newmtime != $modmtime"}
} -result 1
test cmdAH-24.11 {Tcl_FileObjCmd: mtime touch with non-ascii chars} -setup {
    waitForEvenSecondForFAT
    set oldfile $file
} -constraints win -body {
    # introduce some non-ascii characters.
    append file •
    file delete -force $file
    file rename $oldfile $file
    set mtime [file mtime $file]
    after 2100; # pause two secs to notice change in mtime on FAT fs'es
    set newmtime [clock seconds]
    set modmtime [file mtime $file $newmtime]
    expr {$newmtime == $modmtime ? 1 : "$newmtime != $modmtime"}
} -cleanup {
    file rename $file $oldfile
} -result 1
removeFile touch.me
rename waitForEvenSecondForFAT {}
test cmdAH-24.12 {Tcl_FileObjCmd: mtime and daylight savings} -setup {
    set name [file join [temporaryDirectory] clockchange]
    file delete -force $name
    close [open $name w]
} -body {
    set time [clock scan "21:00:00 October 30 2004 GMT"]
    file mtime $name $time
    set newmtime [file mtime $name]
    expr {$newmtime == $time ? 1 : "$newmtime != $time"}
} -cleanup {
    file delete $name
} -result {1}
# bug 1420432: setting mtime fails for directories on windows.
test cmdAH-24.13 {Tcl_FileObjCmd: directory mtime} -setup {
    set dirname [file join [temporaryDirectory] tmp[pid]]
    file delete -force $dirname
} -constraints tempNotWin -body {
    file mkdir $dirname
    set old [file mtime $dirname]
    file mtime $dirname 0
    set new [file mtime $dirname]
    list $new [expr {$old != $new}]
} -cleanup {
    file delete -force $dirname
} -result {0 1}
test cmdAH-24.14 {
    Tcl_FileObjCmd: mtime (built-in Windows names)
} -constraints {win} -body {
    file mtime con
} -result "could not get modification time for file \"con\"" -returnCodes error
test cmdAH-24.14.1 {
    Tcl_FileObjCmd: mtime (built-in Windows names with dir path and extension)
} -constraints {win} -body {
    file mtime [file join [temporaryDirectory] CON.txt]
} -match regexp -result {could not (?:get modification time|read)} -returnCodes error

# 3155760000 is 64-bit unix time, Wed Jan 01 00:00:00 GMT 2070:
test cmdAH-24.20.1 {Tcl_FileObjCmd: atime 64-bit time_t, bug [4718b41c56]} -constraints {time64bit} -setup {
    set filename [makeFile "" foo.text]
} -body {
    list [file atime $filename 3155760000] [file atime $filename]
} -cleanup {
    removeFile $filename
} -result {3155760000 3155760000}
test cmdAH-24.20.2 {Tcl_FileObjCmd: mtime 64-bit time_t, bug [4718b41c56]} -constraints {time64bit} -setup {
    set filename [makeFile "" foo.text]
} -body {
    list [file mtime $filename 3155760000] [file mtime $filename]
} -cleanup {
    file delete -force $filename
} -result {3155760000 3155760000}

# owned
test cmdAH-25.1 {Tcl_FileObjCmd: owned} -returnCodes error -body {
    file owned a b
} -result {wrong # args: should be "file owned name"}
test cmdAH-25.2 {Tcl_FileObjCmd: owned} -constraints win -setup {
    set fn $gorpfile
    # prefer temp file to check owner (try to avoid bug [7de2d722bd]):
    if {
	[info exists ::env(TEMP)] && [file isdirectory $::env(TEMP)] &&
        [file dirname $fn] ne [file normalize $::env(TEMP)]
    } {
	set fn [file join $::env(TEMP)/test-owner-from-tcl.txt]
	set fn [makeFile "data" test-owner-from-tcl.txt $::env(TEMP)]
    }
    # be sure we have really owned this file before trying to check that
    # (avoid dependency on admin with UAC and the setting "System objects:
    # Default owner for objects created by members of the Administrators group"):
    catch {
	exec takeown /F [file nativename $fn]
    }
} -body {
    file owned $fn
} -cleanup {
    if {$fn ne $gorpfile} {
	removeFile $fn
    }
} -result 1
test cmdAH-25.2.1 {Tcl_FileObjCmd: owned} -constraints unix -setup {
    # Avoid problems with AFS
    set tmpfile [makeFile "data" touch.me /tmp]
} -body {
    file owned $tmpfile
} -cleanup {
    removeFile touch.me /tmp
} -result 1
test cmdAH-25.3 {Tcl_FileObjCmd: owned} {unix notRoot} {
    file owned /
} 0
test cmdAH-25.3.1 {Tcl_FileObjCmd: owned} -constraints {win notWine} -body {
    if {[info exists env(SystemRoot)]} {
	file owned $env(SystemRoot)
    } else {
	file owned $env(windir)
    }
} -result 0
test cmdAH-25.4 {Tcl_FileObjCmd: owned} -body {
    file owned nosuchfile
} -result 0

# readlink
test cmdAH-26.1 {Tcl_FileObjCmd: readlink} -returnCodes error -body {
    file readlink a b
} -result {wrong # args: should be "file readlink name"}
test cmdAH-26.2 {Tcl_FileObjCmd: readlink} {unix nonPortable} {
    file readlink $linkfile
} $gorpfile
test cmdAH-26.3 {Tcl_FileObjCmd: readlink errors} {unix nonPortable} {
    list [catch {file readlink _bogus_} msg] [string tolower $msg] $errorCode
} {1 {could not readlink "_bogus_": no such file or directory} {POSIX ENOENT {no such file or directory}}}
test cmdAH-26.5 {Tcl_FileObjCmd: readlink errors} {win nonPortable} {
    list [catch {file readlink _bogus_} msg] [string tolower $msg] $errorCode
} {1 {could not readlink "_bogus_": invalid argument} {POSIX EINVAL {invalid argument}}}

# size
test cmdAH-27.1 {Tcl_FileObjCmd: size} -returnCodes error -body {
    file size a b
} -result {wrong # args: should be "file size name"}
test cmdAH-27.2 {Tcl_FileObjCmd: size} {
    set oldsize [file size $gorpfile]
    set f [open $gorpfile a]
    fconfigure $f -translation lf -eofchar {}
    puts $f "More text"
    close $f
    expr {[file size $gorpfile] - $oldsize}
} {10}
test cmdAH-27.3 {Tcl_FileObjCmd: size} {
    list [catch {file size _bogus_} msg] [string tolower $msg] $errorCode
} {1 {could not read "_bogus_": no such file or directory} {POSIX ENOENT {no such file or directory}}}
test cmdAH-27.4 {
    Tcl_FileObjCmd: size (built-in Windows names)
} -constraints {win} -body {
    file size con
} -result 0
test cmdAH-27.4.1 {
    Tcl_FileObjCmd: size (built-in Windows names with dir path and extension)
} -constraints {win} -body {
    try {
	set res [file size [file join [temporaryDirectory] con.txt]]
    } trap {POSIX ENOENT} {} {
	set res 0
    }
    set res
} -result 0

catch {testsetplatform $platform}
removeFile $gorpfile
set gorpfile [makeFile "Test string" gorp.file]
catch {file attributes $gorpfile -permissions 0o765}

# stat
test cmdAH-28.1 {Tcl_FileObjCmd: stat} -returnCodes error -body {
    file stat
} -result {wrong # args: should be "file stat name ?varName?"}
test cmdAH-28.2 {Tcl_FileObjCmd: stat} -returnCodes error -body {
    file stat _bogus_ a b
} -result {wrong # args: should be "file stat name ?varName?"}
test cmdAH-28.3 {Tcl_FileObjCmd: stat} -setup {
    unset -nocomplain stat
    array set stat {blocks {} blksize {}}
} -body {
    file stat $gorpfile stat
    unset stat(blocks) stat(blksize); # Ignore these fields; not always set
    lsort [array names stat]
} -result {atime ctime dev gid ino mode mtime nlink size type uid}
test cmdAH-28.4 {Tcl_FileObjCmd: stat} -setup {
    unset -nocomplain stat
} -body {
    file stat $gorpfile stat
    list $stat(nlink) $stat(size) $stat(type)
} -result {1 12 file}
test cmdAH-28.5 {Tcl_FileObjCmd: stat} -constraints {unix} -setup {
    unset -nocomplain stat
} -body {
    file stat $gorpfile stat
    format 0o%03o [expr {$stat(mode) & 0o777}]
} -result 0o765
test cmdAH-28.6 {Tcl_FileObjCmd: stat} {
    list [catch {file stat _bogus_ stat} msg] [string tolower $msg] $errorCode
} {1 {could not read "_bogus_": no such file or directory} {POSIX ENOENT {no such file or directory}}}
test cmdAH-28.7 {Tcl_FileObjCmd: stat} -setup {
    unset -nocomplain x
} -returnCodes error -body {
    set x 44
    file stat $gorpfile x
} -result {can't set "x(dev)": variable isn't array}
test cmdAH-28.8 {Tcl_FileObjCmd: stat} -setup {
    set filename [makeFile "" foo.text]
} -body {
    # Sign extension of purported unsigned short to int.
    file stat $filename stat
    expr {$stat(mode) > 0}
} -cleanup {
    removeFile $filename
} -result 1
test cmdAH-28.9 {Tcl_FileObjCmd: stat} win {
    # stat of root directory was failing. Don't care about answer, just that
    # test runs. Relative paths that resolve to root
    set old [pwd]
    cd c:/
    file stat c: stat
    file stat c:. stat
    file stat . stat
    cd $old
    file stat / stat
    file stat c:/ stat
    file stat c:/. stat
} {}
test cmdAH-28.10 {Tcl_FileObjCmd: stat} {win nonPortable} {
    # stat of root directory was failing. Don't care about answer, just that
    # test runs.
    file stat //pop/$env(USERNAME) stat
    file stat //pop/$env(USERNAME)/ stat
    file stat //pop/$env(USERNAME)/. stat
} {}
test cmdAH-28.11 {Tcl_FileObjCmd: stat} -setup {
    set old [pwd]
} -constraints {win nonPortable} -body {
    # stat of network directory was returning id of current local drive.
    cd c:/
    file stat //pop/$env(USERNAME) stat
    expr {$stat(dev) == 2}
} -cleanup {
    cd $old
} -result 0
test cmdAH-28.12 {Tcl_FileObjCmd: stat} -setup {
    set filename [makeFile "" foo.test]
} -body {
    # stat(mode) with S_IFREG flag was returned as a negative number if mode_t
    # was a short instead of an unsigned short.
    file stat $filename stat
    expr {$stat(mode) > 0}
} -cleanup {
    removeFile $filename
} -result 1
test cmdAH-28.13 {Tcl_FileObjCmd: stat (built-in Windows names)} -constraints {win} -setup {
    unset -nocomplain stat
} -body {
    file stat con stat
    lmap elem {atime ctime dev gid ino mode mtime nlink size type uid} {set stat($elem)}
} -result {0 0 -1 0 0 8630 0 0 0 characterSpecial 0}
test cmdAH-28.13.1 {Tcl_FileObjCmd: stat (built-in Windows names)} -constraints {win} -setup {
    unset -nocomplain stat
} -body {
    try {
	file stat [file join [temporaryDirectory] CON.txt] stat
	set res [lmap elem {atime ctime dev gid ino mode mtime nlink size type uid} {set stat($elem)}]
    } trap {POSIX ENOENT} {} {
	set res {0 0 -1 0 0 8630 0 0 0 characterSpecial 0}
    }
    set res
} -result {0 0 -1 0 0 8630 0 0 0 characterSpecial 0}
test cmdAH-28.14 {Tcl_FileObjCmd: stat} -setup {
    unset -nocomplain stat
} -body {
    file stat $gorpfile stat
    expr {
		[lsort -stride 2 [array get stat]]
		eq
		[lsort -stride 2 [file stat $gorpfile]]
	}
} -result {1}
unset -nocomplain stat

# type
test cmdAH-29.1 {Tcl_FileObjCmd: type} -returnCodes error -body {
    file type a b
} -result {wrong # args: should be "file type name"}
test cmdAH-29.2 {Tcl_FileObjCmd: type} {
    file type $dirfile
} directory
test cmdAH-29.3.0 {Tcl_FileObjCmd: delete removes link not file} {unix nonPortable} {
    set exists [list [file exists $linkfile] [file exists $gorpfile]]
    file delete $linkfile
    set exists2	[list [file exists $linkfile] [file exists $gorpfile]]
    list $exists $exists2
} {{1 1} {0 1}}
test cmdAH-29.3 {Tcl_FileObjCmd: type} {
    file type $gorpfile
} file
test cmdAH-29.4 {Tcl_FileObjCmd: type} -constraints {unix} -setup {
    catch {file delete $linkfile}
} -body {
    # Unlike [exec ln -s], [file link] requires an existing target
    file link -symbolic $linkfile $gorpfile
    file type $linkfile
} -cleanup {
    file delete $linkfile
} -result link
test cmdAH-29.4.1 {Tcl_FileObjCmd: type} -constraints {linkDirectory notWine} -setup {
    set tempdir [makeDirectory temp]
} -body {
    set linkdir [file join [temporaryDirectory] link.dir]
    file link -symbolic $linkdir $tempdir
    file type $linkdir
} -cleanup {
    file delete $linkdir
    removeDirectory $tempdir
} -result link
test cmdAH-29.5 {Tcl_FileObjCmd: type} {
    list [catch {file type _bogus_} msg] [string tolower $msg] $errorCode
} {1 {could not read "_bogus_": no such file or directory} {POSIX ENOENT {no such file or directory}}}
test cmdAH-29.6 {
    Tcl_FileObjCmd: type (built-in Windows names)
} -constraints {win} -body {
    file type con
} -result "characterSpecial"
test cmdAH-29.6.1 {
    Tcl_FileObjCmd: type (built-in Windows names, with dir path and extension)
} -constraints {win} -body {
    try {
	set res [file type [file join [temporaryDirectory] CON.txt]]
    } trap {POSIX ENOENT} {} {
	set res {characterSpecial}
    }
    set res
} -result "characterSpecial"

# Error conditions
test cmdAH-30.1 {Tcl_FileObjCmd: error conditions} -returnCodes error -body {
    file gorp x
} -result {unknown or ambiguous subcommand "gorp": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, home, isdirectory, isfile, join, link, lstat, mkdir, mtime, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, tempdir, tempfile, tildeexpand, type, volumes, or writable}
test cmdAH-30.2 {Tcl_FileObjCmd: error conditions} -returnCodes error -body {
    file ex x
} -match glob -result {unknown or ambiguous subcommand "ex": must be *}
test cmdAH-30.3 {Tcl_FileObjCmd: error conditions} -returnCodes error -body {
    file is x
} -match glob -result {unknown or ambiguous subcommand "is": must be *}
test cmdAH-30.4 {Tcl_FileObjCmd: error conditions} -returnCodes error -body {
    file z x
} -match glob -result {unknown or ambiguous subcommand "z": must be *}
test cmdAH-30.5 {Tcl_FileObjCmd: error conditions} -returnCodes error -body {
    file read x
} -match glob -result {unknown or ambiguous subcommand "read": must be *}
test cmdAH-30.6 {Tcl_FileObjCmd: error conditions} -returnCodes error -body {
    file s x
} -match glob -result {unknown or ambiguous subcommand "s": must be *}
test cmdAH-30.7 {Tcl_FileObjCmd: error conditions} -returnCodes error -body {
    file t x
} -match glob -result {unknown or ambiguous subcommand "t": must be *}
test cmdAH-30.8 {Tcl_FileObjCmd: error conditions} -returnCodes error -body {
    file dirname ~woohgy
} -result {user "woohgy" doesn't exist}

# channels
# In testing 'file channels', we need to make sure that a channel created in
# one interp isn't visible in another.

interp create simpleInterp
interp create -safe safeInterp
interp create
catch {safeInterp expose file file}

test cmdAH-31.1 {Tcl_FileObjCmd: channels, too many args} -body {
    file channels a b
} -returnCodes error -result {wrong # args: should be "file channels ?pattern?"}
test cmdAH-31.2 {Tcl_FileObjCmd: channels, too many args} {
    # Normal interps start out with only the standard channels
    lsort [simpleInterp eval [list file chan]]
} {stderr stdin stdout}
test cmdAH-31.3 {Tcl_FileObjCmd: channels, globbing} {
    string equal [file channels] [file channels *]
} {1}
test cmdAH-31.4 {Tcl_FileObjCmd: channels, globbing} {
    lsort [file channels std*]
} {stderr stdin stdout}
set newFileId [open $gorpfile w]
test cmdAH-31.5 {Tcl_FileObjCmd: channels} {
    set res [file channels $newFileId]
    string equal $newFileId $res
} {1}
test cmdAH-31.6 {Tcl_FileObjCmd: channels in other interp} {
    # Safe interps start out with no channels
    safeInterp eval [list file channels]
} {}
test cmdAH-31.7 {Tcl_FileObjCmd: channels in other interp} -body {
    safeInterp eval [list puts $newFileId "hello"]
} -returnCodes error -result "can not find channel named \"$newFileId\""
interp share {} $newFileId safeInterp
interp share {} stdout safeInterp
test cmdAH-31.8 {Tcl_FileObjCmd: channels in other interp} {
    # $newFileId should now be visible in both interps
    list [file channels $newFileId] \
	    [safeInterp eval [list file channels $newFileId]]
} [list $newFileId $newFileId]
test cmdAH-31.9 {Tcl_FileObjCmd: channels in other interp} {
    lsort [safeInterp eval [list file channels]]
} [lsort [list stdout $newFileId]]
test cmdAH-31.10 {Tcl_FileObjCmd: channels in other interp} {
    # we can now write to $newFileId from child
    safeInterp eval [list puts $newFileId "hello"]
} {}
interp transfer {} $newFileId safeInterp
test cmdAH-31.11 {Tcl_FileObjCmd: channels in other interp} {
    # $newFileId should now be visible only in safeInterp
    list [file channels $newFileId] \
	    [safeInterp eval [list file channels $newFileId]]
} [list {} $newFileId]
test cmdAH-31.12 {Tcl_FileObjCmd: channels in other interp} {
    lsort [safeInterp eval [list file channels]]
} [lsort [list stdout $newFileId]]
test cmdAH-31.13 {Tcl_FileObjCmd: channels in other interp} {
    safeInterp eval [list close $newFileId]
    safeInterp eval [list file channels]
} {stdout}

# Temp files (TIP#210)
test cmdAH-32.1 {file tempfile - usage} -returnCodes error -body {
    file tempfile a b c
} -result {wrong # args: should be "file tempfile ?nameVar? ?template?"}
test cmdAH-32.2 {file tempfile - returns a read/write channel} -body {
    set f [file tempfile]
    puts $f ok
    seek $f 0
    gets $f
} -cleanup {
    catch {close $f}
} -result ok
test cmdAH-32.3 {file tempfile - makes filenames} -setup {
    unset -nocomplain name
} -body {
    set result [info exists name]
    set f [file tempfile name]
    lappend result [info exists name] [file exists $name]
    close $f
    lappend result [file exists $name]
} -cleanup {
    catch {close $f}
    catch {file delete $name}
} -result {0 1 1 1}
# We try to obey the template on Unix, but don't (currently) bother on Win
test cmdAH-32.4 {file tempfile - templates} -constraints unix -body {
    close [file tempfile name foo]
    expr {[string match foo* [file tail $name]] ? "ok" : "foo produced $name"}
} -cleanup {
    catch {file delete $name}
} -result ok
test cmdAH-32.5 {file tempfile - templates} -constraints unix -body {
    set template [file join $dirfile foo]
    close [file tempfile name $template]
    expr {[string match $template* $name] ? "ok" : "$template produced $name"}
} -cleanup {
    catch {file delete $name}
} -result ok
# Not portable; not all unix systems have mkstemps()
test cmdAH-32.6 {file tempfile - templates} -body {
    set template [file join $dirfile foo]
    close [file tempfile name $template.bar]
    expr {[string match $template*.bar $name] ? "ok" :
	  "$template.bar produced $name"}
} -constraints {unix nonPortable} -cleanup {
    catch {file delete $name}
} -result ok

test cmdAH-33.1 {file tempdir} -body {
    file tempdir a b
} -returnCodes error -result {wrong # args: should be "file tempdir ?template?"}
test cmdAH-33.2 {file tempdir} -body {
    set d [file tempdir]
    list [file tail $d] [file exists $d] [file type $d] \
	[glob -nocomplain -directory $d *]
} -match glob -result {tcl_* 1 directory {}} -cleanup {
    catch {file delete $d}
}
test cmdAH-33.3 {file tempdir} -body {
    set d [file tempdir gorp]
    list [file tail $d] [file exists $d] [file type $d] \
	[glob -nocomplain -directory $d *]
} -match glob -result {gorp_* 1 directory {}} -cleanup {
    catch {file delete $d}
}
test cmdAH-33.4 {file tempdir} -setup {
    set base [file join [temporaryDirectory] gorp]
    file mkdir $base
} -body {
    set pre [glob -nocomplain -directory $base *]
    set d [file normalize [file tempdir $base/]]
    list [string map [list $base GORP:] $d] [file exists $d] [file type $d] \
	$pre [glob -nocomplain -directory $d *]
} -match glob -result {GORP:/tcl_* 1 directory {} {}} -cleanup {
    catch {file delete -force $base}
}
test cmdAH-33.5 {file tempdir} -setup {
    set base [file join [temporaryDirectory] gorp]
    file mkdir $base
} -body {
    set pre [glob -nocomplain -directory $base *]
    set d [file normalize [file tempdir $base/gorp]]
    list [string map [list $base GORP:] $d] [file exists $d] [file type $d] \
	$pre [glob -nocomplain -directory $d *]
} -match glob -result {GORP:/gorp_* 1 directory {} {}} -cleanup {
    catch {file delete -force $base}
}
test cmdAH-33.6 {file tempdir: missing parent dir} -setup {
    set base [file join [temporaryDirectory] gorp]
    file mkdir $base
} -returnCodes error -body {
    file tempdir $base/quux/
} -cleanup {
    catch {file delete -force $base}
} -result {can't create temporary directory: no such file or directory}
test cmdAH-33.7 {file tempdir: missing parent dir} -setup {
    set base [file join [temporaryDirectory] gorp]
    file mkdir $base
} -returnCodes error -body {
    file tempdir $base/quux/foobar
} -cleanup {
    catch {file delete -force $base}
} -result {can't create temporary directory: no such file or directory}

# This shouldn't work, but just in case a test above failed...
catch {close $newFileId}

interp delete safeInterp
interp delete simpleInterp

# cleanup
catch {testsetplatform $platform}
unset -nocomplain platform

# Tcl_ForObjCmd is tested in for.test

catch {file attributes $dirfile -permissions 0o777}
removeDirectory $dirfile
removeFile $gorpfile
# No idea how well [removeFile] copes with links...
file delete $linkfile

cd $cmdAHwd

::tcltest::cleanupTests
return

# Local Variables:
# mode: tcl
# End:
