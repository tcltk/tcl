# This file contains a collection of tests for Tcl's built-in object system.
# Sourcing this file into Tcl runs the tests and generates output for errors.
# No output means no errors were found.
#
# Copyright (c) 2006 Donal K. Fellows
#
# See the file "license.terms" for information on usage and redistribution of
# this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id: oo.test,v 1.1.2.15 2006/08/28 23:37:51 dkf Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2
    namespace import -force ::tcltest::*
}

test oo-1.1 {basic test of OO functionality: no classes} {
    set result {}
    lappend result [oo::object create foo]
    lappend result [oo::define foo {
	method bar args {
	    global result
	    lappend result {expand}$args
	    return [llength $args]
	}
    }]
    lappend result [foo bar a b c]
    lappend result [foo destroy] [info commands foo]
} {::foo {} a b c 3 {} {}}

test oo-2.1 {basic test of OO functionality: constructor} -setup {
    # This is a bit complex because it needs to run in a sub-interp as
    # we're modifying the root object class's constructor
    interp create subinterp
} -body {
    subinterp eval {
	oo::define oo::object constructor {} {
	    lappend ::result [info level 0]
	}
	lappend result 1
	lappend result 2 [oo::object create foo]
    }
} -cleanup {
    interp delete subinterp
} -result {1 {oo::object create foo} 2 ::foo}

test oo-3.1 {basic test of OO functionality: destructor} -setup {
    # This is a bit complex because it needs to run in a sub-interp as
    # we're modifying the root object class's constructor
    interp create subinterp
} -body {
    subinterp eval {
	oo::define oo::object destructor {
	    lappend ::result died
	}
	lappend result 1 [oo::object create foo]
	lappend result 2 [rename foo {}]
	oo::define oo::object destructor {}
	return $result
    }
} -cleanup {
    interp delete subinterp
} -result {1 ::foo died 2 {}}
test oo-3.2 {basic test of OO functionality: destructor} -setup {
    # This is a bit complex because it needs to run in a sub-interp as
    # we're modifying the root object class's constructor
    interp create subinterp
} -body {
    subinterp eval {
	oo::define oo::object destructor {
	    lappend ::result died
	}
	lappend result 1 [oo::object create foo]
	lappend result 2 [rename foo {}]
    }
} -cleanup {
    interp delete subinterp
} -result {1 ::foo died 2 {}}

test oo-4.1 {basic test of OO functionality: export} {
    set o [oo::object new]
    set result {}
    oo::define $o method Foo {} {lappend ::result Foo; return}
    lappend result [catch {$o Foo} msg] $msg
    oo::define $o export Foo
    lappend result [$o Foo] [$o destroy]
} {1 {unknown method "Foo": must be destroy} Foo {} {}}
test oo-4.2 {basic test of OO functionality: unexport} {
    set o [oo::object new]
    set result {}
    oo::define $o method foo {} {lappend ::result foo; return}
    lappend result [$o foo]
    oo::define $o unexport foo
    lappend result [catch {$o foo} msg] $msg [$o destroy]
} {foo {} 1 {unknown method "foo": must be destroy} {}}

test oo-5.1 {OO: manipulation of classes as objects} -setup {
    set obj [oo::object new]
} -body {
    oo::define oo::object self.method foo {} { return "in object" }
    catch {$obj foo} result
    list [catch {$obj foo} result] $result [oo::object foo]
} -cleanup {
    oo::define oo::object self.method foo {} {}
    $obj destroy
} -result {1 {unknown method "foo": must be destroy} {in object}}

test oo-6.1 {OO: filter} {
    oo::object create foo
    oo::define foo {
	forward a lappend
	forward b lappend result
    }
    set result {}
    foo a result 1
    foo b 2
    foo destroy
    return $result
} {1 2}

test oo-7.1 {OO: inheritance 101} -setup {
    oo::class create superClass
    oo::class create subClass
    subClass create instance
} -body {
    oo::define superClass method doit x {lappend ::result $x}
    oo::define subClass superclass superClass
    set result [list [catch {subClass doit bad} msg] $msg]
    instance doit ok
    return $result
} -cleanup {
    subClass destroy
    superClass destroy
} -result {1 {unknown method "doit": must be create, destroy or new} ok}
test oo-7.2 {OO: inheritance 101} -setup {
    oo::class create superClass
    oo::class create subClass
    subClass create instance
} -body {
    oo::define superClass method doit x {lappend ::result |$x|}
    oo::define subClass superclass superClass
    oo::define instance method doit x {lappend ::result =$x=; next [incr x]}
    set result {}
    instance doit 1
    return $result
} -cleanup {
    subClass destroy
    superClass destroy
} -result {=1= |2|}
test oo-7.3 {OO: inheritance 101} -setup {
    oo::class create superClass
    oo::class create subClass
    subClass create instance
} -body {
    oo::define superClass method doit x {lappend ::result |$x|}
    oo::define subClass {
	superclass superClass
	method doit x {lappend ::result -$x-; next [incr x]}
    }
    oo::define instance method doit x {lappend ::result =$x=; next [incr x]}
    set result {}
    instance doit 1
    return $result
} -cleanup {
    subClass destroy
    superClass destroy
} -result {=1= -2- |3|}
test oo-7.4 {OO: inheritance from oo::class} -body {
    oo::class create meta
    oo::define meta {
	superclass oo::class
	self.unexport create new
	self.method make {x {definitions {}}} {
	    if {![string match ::* $x]} {
		set ns [uplevel 1 {::namespace current}]
		set x ${ns}::$x
	    }
	    set o [my create $x]
	    lappend ::result "made $o"
	    oo::define $o $definitions
	    return $o
	}
    }
    set result [list [catch {meta create foo} msg] $msg]
    lappend result [meta make classinstance {
	lappend ::result "in definition script in [namespace current]"
    }]
    lappend result [classinstance create instance]
} -cleanup {
    catch {classinstance destroy}
    catch {meta destroy}
} -result {1 {unknown method "create": must be destroy or make} {made ::classinstance} {in definition script in ::oo::define} ::classinstance ::instance}
test oo-7.5 {OO: inheritance from oo::class in the secondary chain} -body {
    oo::class create other
    oo::class create meta
    oo::define meta {
	superclass other oo::class
	self.unexport create new
	self.method make {x {definitions {}}} {
	    if {![string match ::* $x]} {
		set ns [uplevel 1 {::namespace current}]
		set x ${ns}::$x
	    }
	    set o [my create $x]
	    lappend ::result "made $o"
	    oo::define $o $definitions
	    return $o
	}
    }
    set result [list [catch {meta create foo} msg] $msg]
    lappend result [meta make classinstance {
	lappend ::result "in definition script in [namespace current]"
    }]
    lappend result [classinstance create instance]
} -cleanup {
    catch {classinstance destroy}
    catch {meta destroy}
    catch {other destroy}
} -result {1 {unknown method "create": must be destroy or make} {made ::classinstance} {in definition script in ::oo::define} ::classinstance ::instance}
test oo-7.6 {OO: inheritance 101 - overridden methods should be oblivious} -setup {
    oo::class create Aclass
    oo::class create Bclass
    Bclass create Binstance
} -body {
    oo::define Aclass {
	method incr {var step} {
	    upvar 1 $var v
	    ::incr v $step
	}
    }
    oo::define Bclass {
	superclass Aclass
	method incr {var {step 1}} {
	    global result
	    lappend result $var $step
	    set r [next $var $step]
	    lappend result returning:$r
	    return $r
	}
    }
    set result {}
    set x 10
    lappend result x=$x
    lappend result [Binstance incr x]
    lappend result x=$x
} -result {x=10 x 1 returning:11 11 x=11} -cleanup {
    Aclass destroy
}

test oo-8.1 {OO: global must work in methods} {
    oo::object create foo
    oo::define foo method bar x {global result; lappend result $x}
    set result {}
    foo bar this
    foo bar is
    lappend result a
    foo bar test
    foo destroy
    return $result
} {this is a test}

test oo-9.1 {OO: multiple inheritance} -setup {
    oo::class create A
    oo::class create B
    oo::class create C
    oo::class create D
    D create foo
} -body {
    oo::define A method test {} {lappend ::result A; return ok}
    oo::define B {
	superclass A
	method test {} {lappend ::result B; next}
    }
    oo::define C {
	superclass A
	method test {} {lappend ::result C; next}
    }
    oo::define D {
	superclass B C
	method test {} {lappend ::result D; next}
    }
    set result {}
    lappend result [foo test]
} -cleanup {
    D destroy
    C destroy
    B destroy
    A destroy
} -result {D B C A ok}
test oo-9.2 {OO: multiple inheritance} -setup {
    oo::class create A
    oo::class create B
    oo::class create C
    oo::class create D
    D create foo
} -body {
    oo::define A method test {} {lappend ::result A; return ok}
    oo::define B {
	superclass A
	method test {} {lappend ::result B; next}
    }
    oo::define C {
	superclass A
	method test {} {lappend ::result C; next}
    }
    oo::define D {
	superclass B C
	method test {} {lappend ::result D; next}
    }
    set result {}
    lappend result [foo test]
} -cleanup {
    A destroy
} -result {D B C A ok}

test oo-10.1 {OO: recursive invoke and modify} -setup {
    [oo::class create C] create O
} -cleanup {
    C destroy
} -body {
    oo::define C method foo x {
	lappend ::result $x
	if {$x} {
	    [self object] foo [incr x -1]
	}
    }
    oo::define O method foo x {
	lappend ::result -$x-
	if {$x == 1} {
	    # delete the method
	    oo::define O method foo {} {}
	}
	next $x
    }
    set result {}
    O foo 2
    return $result
} -result {-2- 2 -1- 1 0}

test oo-11.1 {OO: cleanup} {
    oo::object create foo
    set result [list [catch {oo::object create foo} msg] $msg]
    lappend result [foo destroy] [oo::object create foo] [foo destroy]
} {1 {can't create object "foo": command already exists with that name} {} ::foo {}}
test oo-11.2 {OO: cleanup} {
    oo::class create bar
    bar create foo
    set result [list [catch {bar create foo} msg] $msg]
    lappend result [bar destroy] [oo::object create foo] [foo destroy]
} {1 {can't create object "foo": command already exists with that name} {} ::foo {}}
test oo-11.3 {OO: cleanup} {
    oo::class create bar0
    oo::class create bar
    oo::define bar superclass bar0
    bar create foo
    set result [list [catch {bar create foo} msg] $msg]
    lappend result [bar0 destroy] [oo::object create foo] [foo destroy]
} {1 {can't create object "foo": command already exists with that name} {} ::foo {}}
test oo-11.4 {OO: cleanup} {
    oo::class create bar0
    oo::class create bar1
    oo::define bar1 superclass bar0
    oo::class create bar2
    oo::define bar2 {
	superclass bar0
	destructor {lappend ::result destroyed}
    }
    oo::class create bar
    oo::define bar superclass bar1 bar2
    bar create foo
    set result [list [catch {bar create foo} msg] $msg]
    lappend result [bar0 destroy] [oo::object create foo] [foo destroy] \
	[oo::object create bar2] [bar2 destroy]
} {1 {can't create object "foo": command already exists with that name} destroyed {} ::foo {} ::bar2 {}}

test oo-12.1 {OO: filters} {
    oo::class create Aclass
    Aclass create Aobject
    oo::define Aclass {
	method concatenate args {
	    global result
	    lappend result {expand}$args
	    join $args {}
	}
	method logFilter args {
	    global result
	    lappend result "calling [self object]->[self method] $args"
	    set r [next {expand}$args]
	    lappend result "result=$r"
	    return $r
	}
    }
    oo::define Aobject filter logFilter
    set result {}
    lappend result [Aobject concatenate 1 2 3 4 5]
    Aclass destroy
    return $result
} {{calling ::Aobject->logFilter 1 2 3 4 5} 1 2 3 4 5 result=12345 12345}
test oo-12.2 {OO: filters} knownBug {
    oo::class create Aclass
    Aclass create Aobject
    oo::define Aclass {
	method concatenate args {
	    global result
	    lappend result {expand}$args
	    join $args {}
	}
	method logFilter args {
	    global result
	    lappend result "calling [self object]->[self method] $args"
	    set r [next {expand}$args]
	    lappend result "result=$r"
	    return $r
	}
    }
    oo::define Aobject filter logFilter
    set result {}
    lappend result [Aobject concatenate 1 2 3 4 5]
    Aobject destroy
    Aclass destroy
    return $result
} {{calling ::Aobject->logFilter 1 2 3 4 5} 1 2 3 4 5 result=12345 12345}

test oo-13.1 {OO: changing an object's class} {
    oo::class create Aclass
    oo::define Aclass {method bar {} {lappend ::result "in A [self object]"}}
    oo::class create Bclass
    oo::define Bclass {method bar {} {lappend ::result "in B [self object]"}}
    set result [Aclass create foo]
    foo bar
    oo::define foo self.class Bclass
    foo bar
    Aclass destroy
    lappend result [info command foo]
    Bclass destroy
    return $result
} {::foo {in A ::foo} {in B ::foo} foo}
test oo-13.2 {OO: changing an object's class} -body {
    oo::object create foo
    oo::define foo self.class oo::class
} -cleanup {
    foo destroy
} -returnCodes 1 -result {may not change a non-class object into a class object}
test oo-13.3 {OO: changing an object's class} -body {
    oo::class create foo
    oo::define foo self.class oo::object
} -cleanup {
    foo destroy
} -returnCodes 1 -result {may not change a class object into a non-class object}
# todo: changing a class subtype (metaclass) to another class subtype

test oo-14.1 {OO: mixins} {
    oo::class create Aclass
    oo::define Aclass method bar {} {lappend ::result "[self object] in bar"}
    oo::class create Bclass
    oo::define Bclass method boo {} {lappend ::result "[self object] in boo"}
    oo::define [Aclass create fooTest] mixin Bclass
    oo::define [Aclass create fooTest2] mixin Bclass
    set result [list [catch {fooTest ?} msg] $msg]
    fooTest bar
    fooTest boo
    fooTest2 bar
    fooTest2 boo
    oo::define fooTest2 mixin
    lappend result [Bclass destroy] [info command fooTest*] [Aclass destroy]
} {1 {unknown method "?": must be bar, boo or destroy} {::fooTest in bar} {::fooTest in boo} {::fooTest2 in bar} {::fooTest2 in boo} {} fooTest2 {}}

test oo-15.1 {OO: object cloning} {
    oo::class create Aclass
    oo::define Aclass method test {} {lappend ::result [self object]->test}
    Aclass create Ainstance
    set result {}
    Ainstance test
    oo::define Ainstance copy Binstance
    Binstance test
    Ainstance test
    Ainstance destroy
    namespace eval foo {
	oo::define Binstance copy Cinstance
	Cinstance test
    }
    Aclass destroy
    namespace delete foo
    lappend result [info commands Binstance]
} {::Ainstance->test ::Binstance->test ::Ainstance->test ::foo::Cinstance->test {}}
# Anything involving methods or classes is not cloned correctly yet.

cleanupTests
return

# Local Variables:
# mode: tcl
# End:
